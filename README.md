---
# A REACT-REDUX STARTER KIT WITH WEBPACK 2
---

* Start Date: 04 Mar 2017 

* This markdown file was written based on the guidlines [here](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet)

* You can also use: <https://stackedit.io> to create a .md file in a WYSIWYG fashion.

* git repo: https://github.com/zonender/react-redux-weback2-starter

* Author: [Asim Abdelgadir](https://github.com/zonender)

* OS: Windows 10 (64-bit)

* Browser: Chrome Version 56.0.2924.87 (64-bit)

* Editor: Visual Studio Code version 1.10.1

* VS CODE File Icon theme: Go to the plugins side menu: type: vscode-icons, locate the plugin, install it, reload, then goto File > Preferences > select "File Icon Theme".

* Node version: 7.5.0

* npm version: 4.2.0

* Command language (SHELL): Git Bash version: 2.11.1 (64-bit)

* Version control: Git version: 2.11.1 (64-bit) and <www.github.com>

* Awesome references:

  - http://javascriptplayground.com/blog/2016/10/moving-to-webpack-2/
  - For more on the configuration of webpack 2: https://github.com/webpack/docs/wiki/configuration
  - For more on webpack's cli commands: https://webpack.github.io/docs/cli.html
  - https://www.npmjs.com/package/@taion/extract-text-webpack-plugin


> **_//==============================================================\\_**
>
> **_.GITIGNORE AND README.MD_**
>
> **_\\==============================================================//_**

01. ) Start with an empty folder in your desktop and call it "react-redux-weback2-starter" or any other name you choose, this is going to be your root directory, and we 
will call it your root.

01. ) Create README.md file in your root and write the following in it:
  
   01. ) describe every step taken.
  
   01. ) every file created.
  
   01. ) every code written, new or updated and which file it was written in, you write the line(s) of code in one section and then copy and paste the entire file into a 
   separate section underneath it.
  
   01. ) every issue encountered, steps to reproduce, why it happened if possible and how it was solved with references and links.

01. ) Create .gitignore with the following content:

```
# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# node-waf configuration
.lock-wscript

# Compiled binary addons (http://nodejs.org/api/addons.html)
build/Release

# Dependency directory
# https://www.npmjs.org/doc/misc/npm-faq.html#should-i-check-my-node_modules-folder-into-git
node_modules

#dist folder
dist

#build folder
build

#Webstorm metadata
.idea

# Mac files
.DS_Store
```

> **_//==============================================================\\_**
>
> **_EDITOR AND CONFIGURATION | EDITORCONFIG_**
>
> **_\\==============================================================//_**

To make sure everyone inn your team, if you are working with a team, is using the same editor setting we will enforce these setting through the editor config file.

01. ) Create the file .editorconfig in your root with the following content, All future files created will be formatted based on the settings in this file.

  ```
  # editorconfig.org
  root = true

  [*]
  indent_style = space
  indent_size = 2
  end_of_line = lf
  charset = utf-8
  trim_trailing_whitespace = true
  insert_final_newline = true

  [*.md]
  trim_trailing_whitespace = false
  ```

01. ) Go to <www.editorconfig.org> to download and install your editor's plugin, now your editor will enforce the setting in the .editorconfig, 
don't forget to enable the plugin after you installed it. 

> **_//==============================================================\\_**
>
> **_.GITIGNORE AND README.MD_**
>
> **_\\==============================================================//_**

01. ) Start with an empty folder in your desktop and call it "react-redux-weback2-starter" or any other name you choose, this is going to be your root directory, and we 
will call it your root.

01. ) Create README.md file in your root and write the following in it:
  
   01. ) describe every step taken.
  
   01. ) every file created.
  
   01. ) every code written, new or updated and which file it was written in, you write the line(s) of code in one section and then copy and paste the entire file into a 
   separate section underneath it.
  
   01. ) every issue encountered, steps to reproduce, why it happened if possible and how it was solved with references and links.

01. ) Create .gitignore with the following content:

```
# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# node-waf configuration
.lock-wscript

# Compiled binary addons (http://nodejs.org/api/addons.html)
build/Release

# Dependency directory
# https://www.npmjs.org/doc/misc/npm-faq.html#should-i-check-my-node_modules-folder-into-git
node_modules

#dist folder
dist

#build folder
build

#Webstorm metadata
.idea

# Mac files
.DS_Store
```

> **_//==============================================================\\_**
>
> **_EDITOR AND CONFIGURATION | EDITORCONFIG_**
>
> **_\\==============================================================//_**

To make sure everyone inn your team, if you are working with a team, is using the same editor setting we will enforce these setting through the editor config file.

01. ) Create the file .editorconfig in your root with the following content, All future files created will be formatted based on the settings in this file.

  ```
  # editorconfig.org
  root = true

  [*]
  indent_style = space
  indent_size = 2
  end_of_line = lf
  charset = utf-8
  trim_trailing_whitespace = true
  insert_final_newline = true

  [*.md]
  trim_trailing_whitespace = false
  ```

01. ) Go to <www.editorconfig.org> to download and install your editor's plugin, now your editor will enforce the setting in the .editorconfig, 
don't forget to enable the plugin after you installed it. 

> **_//==============================================================\\_**
>
> **_INSTALL NODE, NPM, GIT, BASH AND NSP_**
>
> **_\\==============================================================//_**

01. ) install node.js from: <https://nodejs.org/en/>

01. ) npm is part of the node.js installation, however, you can install it from the command line:

```
npm install npm -g
```

01. ) Install Git from: <https://git-scm.com/> this will also install Git Bash command line.

01. ) To Use Git Bash terminal within VS Code: <https://code.visualstudio.com/docs/editor/integrated-terminal>, this is very convenient.

01. ) Create a file called package.json in your root and paste the content of this [package.json](https://gist.github.com/zonender/40564da81b864b3654ac98ab30940fbb) inside
 the package.json you just created, then save it.

For your convenience and just incase you were unable to get the package.json from the link above, copy and paste the following code inside the package.json file:

```
{
  "name": "rreact-redux-weback2-starter",
  "version": "1.0.0",
  "description": "Starter kit with React, Redux and Webpack2",
  "scripts": {

  },
  "author": "Asim Abdelgadir",
  "license": "MIT",
  "dependencies": {
    "babel-polyfill": "6.8.0",
    "bootstrap": "3.3.6",
    "jquery": "2.2.3",
    "react": "15.0.2",
    "react-dom": "15.0.2",
    "react-redux": "4.4.5",
    "react-router": "2.4.0",
    "react-router-redux": "4.0.4",
    "redux": "3.5.2",
    "redux-thunk": "2.0.1",
    "toastr": "2.1.2"
  },
  "devDependencies": {
    "babel-cli": "6.8.0",
    "babel-core": "6.8.0",
    "babel-loader": "6.2.4",
    "babel-plugin-react-display-name": "2.0.0",
    "babel-preset-es2015": "6.6.0",
    "babel-preset-react": "6.5.0",
    "babel-preset-react-hmre": "1.1.1",
    "babel-register": "6.8.0",
    "cheerio": "0.22.0",
    "colors": "1.1.2",
    "compression": "1.6.1",
    "cross-env": "1.0.7",
    "css-loader": "^0.23.1",
    "enzyme": "2.2.0",
    "eslint": "2.9.0",
    "eslint-plugin-import": "1.6.1",
    "eslint-plugin-react": "5.0.1",
    "eslint-watch": "2.1.11",
    "eventsource-polyfill": "0.9.6",
    "expect": "1.19.0",
    "express": "4.13.4",
    "extract-text-webpack-plugin": "1.0.1",
    "file-loader": "0.8.5",
    "html-webpack-plugin": "^2.28.0",
    "jsdom": "8.5.0",
    "localtunnel": "^1.8.2",
    "mocha": "2.4.5",
    "nock": "8.0.0",
    "npm-run-all": "1.8.0",
    "nsp": "^2.6.2",
    "open": "0.0.5",
    "react-addons-test-utils": "15.0.2",
    "redux-immutable-state-invariant": "1.2.3",
    "redux-mock-store": "1.0.2",
    "rimraf": "^2.5.2",
    "style-loader": "^0.13.1",
    "url-loader": "^0.5.7",
    "webpack": "1.13.0",
    "webpack-dev-middleware": "1.6.1",
    "webpack-hot-middleware": "2.10.0",
    "webpack-md5-hash": "0.0.5"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/zonender/react-redux-weback2-starter"
  }
}
```

01. ) Then run:

```
npm install
```

This will install all the dependencies in the package.json to our project.

01. ) To scan all the dependencies in the package.json file we can use Node Security Platform, it is already part of the devDependencies in the package.json file, 
but if you still want to install it run this command in your terminal/command line, going forward, when we say "run this command" we are refering to running the command
from within the terminal/command line:

```
npm install nsp --save-dev
```

then to run the security check run this command:

```
nsp check
```

> **_//==============================================================\\_**
>
> **_SETTING UP EXPRESS AS A DEVELOPMENT WEB SERVER_**
>
> **_\\==============================================================//_**

01. ) Express is already installed in our project as a dev dependency in our package.json, but just incase you need to install it, run this command:

  ```
  npm install express --save-dev
  ```

  We will just need to configure it as follows:

01. ) Create a directory called src in the root, inside it create index.html with this code:

  ```
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <title></title>
      <meta charset="UTF-8">
    </head>
    <body>
      <h1>Hello World!</h1>
    </body>
  </html>
  ```

01. ) It is best to keep all the build tools in a single directory called buildScripts in the root of our project, inside the directory create the file srcServer.js
  in it put this code:
  
  ```
  var express = require('express');
  var path = require('path');
  var open = require('open');

  var port = 3000;
  var app = express();

  app.get('/', function(req, res) {
    res.sendFile(path.join(__dirname, '../src/index.html'));
  });

  app.listen(port, function(err) {
    if (err) {
      console.log(err);
    } else {
      open('http://localhost:' + port);
    }
  });
  ```

  now to run this file with the express server, run this command:

  ```
  node buildScripts/srcServer.js
  ```

  Express will open the browser with the page we just created, now we know we configured express correctly since it is listening to and serving our requests.

  Just in case you ever need to open the index.html without a server, run this command:

  ```
  start src/index.html
  ```

  The page will open in your browser without the server, the page should display only: "Hello World!".

> **_//==============================================================\\_**
>
> **_SETTING UP BABEL (USING ES6)_**
>
> **_\\==============================================================//_**

Transpiling means changing ES6 code (ES2015) into ES5 to ensure our JS code runs in the browsers that do not yet fully support the latest version of JS, we will 
now be using ES5 and Babel will transpile our code to ES5, we already installed Babel when we first ran "npm install" it is one of the many packages included in 
our package.json, so we just have to configure it:

To configure babel:

01. ) Create a file called: .babelrc with the following code:

```
{
  "presets": ["es2015", "react"],
  "env": {
    "development": {
      "presets": ["react-hmre"]
    }
  }
}
```

01. ) To run our app this time we will need to slightly change our command, instead of the key word "node", we will use "babel-node" as follows:

```
babel-node buildScripts/srcServer.js
```

> **_//==============================================================\\_**
>
> **_CREATING A BASIC APP_**
>
> **_\\==============================================================//_**


01. ) Create an src/index.js file with the following code and save it under src:

  ```
  import talk from './talktoconsole';
  console.log(talk(1, 2));

  const button = document.createElement('button');
  button.innerText = 'Click me';
  button.onclick = () => {
      System.import('./image_viewer').then(module => {
          module.default();
      });
  };

  document.body.appendChild(button);
  ```

01. ) Create the file src/talkToConsole.js with the following code:
  
  ```
  import numeral from 'numeral';

  const talk = (a, b) =>numeral(a + b).format('$0.0.00');

  export default talk;
  ```
01. ) Create the file src/image_viewer.js with the following code:

  ```
  import small from '../assets/small.jpg';
  import big from '../assets/big.jpg';
  import './styles/image_viewer.css';

  export default () => {

      const smallImageDescription = document.createElement('p');
      smallImageDescription.innerText = 'This is a small Image that was small enough to be bundled into bundle.js';
      document.body.appendChild(smallImageDescription);

      const smallImage = document.createElement('img');
      smallImage.src = small;
      document.body.appendChild(smallImage);

      const bigImageDescription = document.createElement('p');
      bigImageDescription.innerText = 'This is a big Image, because it is large it was not bundled in bundle.js';
      document.body.appendChild(bigImageDescription);

      const bigImage = document.createElement('img');
      bigImage.src = big;
      document.body.appendChild(bigImage);

      const randomImageDescription = document.createElement('p');
      randomImageDescription.innerText = 'This is a random image generated from http://lorempixel.com/';
      document.body.appendChild(randomImageDescription);

      const randomImage = document.createElement('img');
      randomImage.src = 'http://lorempixel.com/400/200/';
      document.body.appendChild(randomImage);
  };
  ```

01. ) Create a src/styles folder, within the styles folder create a css file src/styles/style.css with the following css code:

```
img {
    border: 10px solid red;
}
```
01. ) Create an assets folder in the root directory and save the following images into them:

http://lorempixel.com/200/200/ - call this small.jpg

http://lorempixel.com/1200/1200/ - call this big.jpg

01. ) Now we must include the three new js files in our src/index.html page as script tags just before the closing "body" tag like this:

```
    <script type="text/javascript" src="index.js"></script>
    <script type="text/javascript" src="image_viewer.js"></script>
    <script type="text/javascript" src="talkToConsole.js"></script>

```

So our src/index.html becomes:

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <title></title>
    <meta charset="UTF-8">
  </head>
  <body>
    <h1>Hello World!</h1>
    <script type="text/javascript" src="index.js"></script>
    <script type="text/javascript" src="image_viewer.js"></script>
    <script type="text/javascript" src="talkToConsole.js"></script>
  </body>
</html>
```

01. ) Then we have to make sure they are served through the express server by adding the following line in our srcServer.js file:

```
app.use(express.static(path.join(__dirname, '../src')));
```

So our srcServer.js file becomes:

```
import express from 'express';
import path from 'path';
import open from 'open';

const port = 3000;
const app = express();

app.use(express.static(path.join(__dirname, '../src')));

app.get('/', function(req, res) {
  res.sendFile(path.join(__dirname, '../src/index.html'));
});

app.listen(port, function(err) {
  if (err) {
    console.log(err);
  } else {
    open('http://localhost:' + port);
  }
});
```

Now run the app by running the following command, please note that the app will not run as expected:

```
babel-node buildScripts/srcServer.js
```

We are supposed to see a button labeled "Click me", it will not show up, and if you use the "inspect element" tool and open the console, you will see the error message:

  - Uncaught SyntaxError: Unexpected token import      index.js:1
  - Uncaught SyntaxError: Unexpected token import      image_viewer.js:1
  - Uncaught SyntaxError: Unexpected token import      talkToConsole.js:1

This is because the browser is unable to interpret the ES6 "import" statement in the first line of each file, to solve this we will need to install webpack to compile the code and 
bundle it in a single file and in plain JS so that the broweser can understand it and eventually display our button along with its functionality.

> **_//=========================================================================\\_**
>
> **_SETTING UP WEBPACK AS A DEVELOPMENT SERVER AND COMPILING AND BUNDLING OUR CODE_**
>
> **_\\=========================================================================//_**

Now that we have a working app, we can now configure webpack.

  - For more on the configuration of webpack 2: https://github.com/webpack/docs/wiki/configuration
  - For more on webpack's cli commands: https://webpack.github.io/docs/cli.html

01. ) Create a webpack.config.dev.js file in our root with the following code:

    ```
    const webpack = require('webpack');
    const path = require('path');
    const htmlWebpackPlugin = require('html-webpack-plugin');

    const config = {
      //The entry point for the bundle.
      devtool: 'cheap-module-eval-source-map',
      entry: {
        bundle: path.resolve(__dirname, 'src/index')
      },
      output: {
        path: path.join(__dirname, 'dist'),
        publicPath: '/',
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            use: ['babel-loader'], //here we are selecting the loader
            test: /(\.js|\.jsx)$/, //and here we specify which file the loader will process
            exclude: /node_modules/
          },
          {
            test: /\.css$/,
            use: ['style-loader', 'css-loader']
          },
          {
            test: /\.(jpe?g|jpg|png|gif|svg)$/,
            use: [
              {
                loader: 'url-loader'
              },
              'image-webpack-loader'
            ]
          }
        ]
      },
      plugins: [
          //this plugin will insert the script tags for bundle.js and vendor.js in our index.html
          new htmlWebpackPlugin({
                template: 'src/index.html' //if we do not specifiy a template, it will use the default one
          }),
          new webpack.LoaderOptionsPlugin({
            options: {
                noInfo: false,
                debug: true,
                devtool: 'inline-source-map',
                target: 'web'
            }
          })
      ]
    };

    module.exports = config;
    ```

    - path makes sure we get the path we need regardless of the OS it is running on.

    - __dirname is the current directory. (where webpack.config.dev.js is located)

    - entry: "./src/index.js" is the top level file we want to include in our build.

    - filename: "bundle.js" is the output file that has includes all out JS code.

    Please note that webpack will not physically create a bundle.js file in our directory when we later run "webpack-dev-server", rather it will create everything 
    in memory, the physical file bundle.js and any other required file will be created later when we compile our code using the "webpack" command.

    Webpack will bundle together all our js files into a single file called bundle.js, webpack will also bundle any css,
    and images into the bundle.js file, then webpack will inject this file in the index.html file, so now let's prepare things for webpack before we start using it.

    Webpack will also split our code to improve loaiding performance.

    installing webpack or any other library globally will force your pc to look for the global installation of node_modules under your username folder in your pc, which could include a large number of modules and libraries, this might be slightly slower, it is best to install it locally using "npm install --save-dev" so that next time you run the command npm will look only in our locally installed node_modules, this is faster.

01. ) Remove the script tags that represents our three js files in our src/index.html file, the file becomes:

    ```
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <title></title>
        <meta charset="UTF-8">
      </head>
      <body>
        <h1>Hello World!</h1>
      </body>
    </html>
    ```

01. ) In the buildScripts/srcServer.js file remove the line below which we were using to demonstrate that we can't run our app without compiling it with webpack:

    ```
    app.use(express.static(path.join(__dirname, '../src')));
    ```

    And add the following import statements:

    ```
    import webpack from 'webpack';
    import config from '../webpack.config.dev';
    ```

    Then add the following code:

    ```
    const compiler = webpack(config);

    app.use(require('webpack-dev-middleware')(compiler, {
      noInfo: true,
      publicPath: config.output.publicPath
    }));
    ```

    The final version of our buildScripts/srcServer.js becomes:

    ```
    import express from 'express';
    import path from 'path';
    import open from 'open';
    import webpack from 'webpack';
    import config from '../webpack.config.dev';

    const port = 3000;
    const app = express();
    const compiler = webpack(config);

    app.use(require('webpack-dev-middleware')(compiler, {
      noInfo: true,
      publicPath: config.output.publicPath
    }));

    app.get('/', function(req, res) {
      res.sendFile(path.join(__dirname, '../src/index.html'));
    });

    app.listen(port, function(err) {
      if (err) {
        console.log(err);
      } else {
        open('http://localhost:' + port);
      }
    });
    ```

    With this configuration we can now use webpack as our dev server, to run the project using webpack dev server run this command:

    ```
    webpack-dev-server
    ```

    We can also still run our app through express using the command:

    ```
    babel-node buildScripts/srcServer.js
    ```

    To run our app with the webpack-dev-server we will use this command:

    ```
    webpack-dev-server --config webpack.config.dev.js
    ```

    Running the command "webpack-dev-server" alone like this:

    ```
    webpack-dev-server
    ```

    will have webpack-dev-server assume you are using the default config file name: "webpack.config.js", which is not the case in our app, since our webpack config file is named: "webpack.config.dev.js", we can have several webpack config files if we need.

    Note:
    We also have the hot reloading feature already available, if you change index.html or index.js and save, the browser will automatically show the changes.

> **_//==============================================================\\_**
>
> **_SHARING OUR WORK IN PROGRESS WITH LOCALTUNNEL_**
>
> **_\\==============================================================//_**

01. ) Install localtunnel globally:

    ```
    npm install -g localtunnel
    ```

01. ) Run our app:

    ```
    node buildScripts/srcServer.js
    ```

    THe ap will open in the browser, Leave the app running

01. ) Open another command line and run localtunnel from there:

    ```
    lt --port 3000
    ```

    localtunnel will return a url such as: <https://tbwsccjuzv.localtunnel.me/> from which we can access our app, you can provide this url to anyone to share yuor work in progress, 
    we can even use this command:

    ```
    lt --port 3000 --subdomain asimtestapp
    ```

    It should return <https://asimtestapp.localtunnel.me/> that we can use.

> **_//==============================================================\\_**
>
> **_AUTOMATION USING NPM SCRIPTS_**
>
> **_\\==============================================================//_**

npm scripts allows you to: make command line call, utilize npm packages, call separate scripts that use node, call separate files, create, update and remove files and directories
, which is very useful in creating a reliable build process, we can create npm scripts in the "script" section of the package.json.

also, with npm script we do not need to install npm modules globally to run them, when we run "npm install" to install all the packages listed in our package.json file they get added
to a ".bin" folder inside the "node_modules" folder of our root, this makes them available to our project, all those modules in the .bin folder are automatically in path when we call
 them from the command line in our root project folder.

01. ) This is how we create the "start" script in the package.json file:

    ```
        "scripts": {
          "start": "node buildScripts/srcServer.js"
        },
    ```

      now to run this script we run this in the command line:

      ```
      npm run start
      ```

      or

      ```
      npm start
      ```

      The same applies for "npm test", all other npm scripts must be used with the "run" key word.

01. ) Creating a script that displays a message when running the app:

      we do this by creating a startMessage.js file in the buildScripts folder with the following code:

      ```
      var chalk = require('chalk');
      console.log(chalk.green('Starting app in dev mode...'));
      ```

      then we write an npm script to run it before our app runs, this is done with the prefix "pre", there is also a "post" prefix, these are called hooks, 
      observe the script section of the package.json:

    ```
        "scripts": {
          "prestart": "node buildScripts/startMessage.js",
          "start": "node buildScripts/srcServer.js"
        },
    ```

      the script "prestart" will run before the "start" script, to see this in action run this command:

      ```
      npm start
      ```

01. ) Creating a script that runs the security check in parallel to the start script when the app starts, observe the "script section":

    ```
        "scripts": {
          "prestart": "node buildScripts/startMessage.js",
          "start": "npm-run-all --parallel security-check open:src",
          "open:src": "node buildScripts/srcServer.js",
          "security-check": "nsp check"
        },
    ```


      If you get too much info in the console, use:

      ```
      npm start -s
      ```

      which will run the script in silent mode.

01. ) Creating a script that runs localtunnel in parallel to the start script when the app starts, observe the "script section":

    ```
        "scripts": {
          "prestart": "node buildScripts/startMessage.js",
          "start": "npm-run-all --parallel security-check open:src",
          "open:src": "node buildScripts/srcServer.js",
          "security-check": "nsp check",
          "localtunnel": "lt --port 3000",
          "share": "npm-run-all --parallel open:src localtunnel"
        },
    ```

    This way we avoided opening two terminals at the same time like we did before when setting up localtunnel, we just run:

    ```
    npm run share
    ```

01. ) Creating a script that runs our app with the webpack-dev-server, observe the "script section":

    ```
        "scripts": {
          "prestart": "node buildScripts/startMessage.js",
          "start": "npm-run-all --parallel security-check open:src",
          "open:src": "node buildScripts/srcServer.js",
          "security-check": "nsp check",
          "localtunnel": "lt --port 3000",
          "share": "npm-run-all --parallel open:src localtunnel",
          "serve": "webpack-dev-server --config webpack.config.dev.js"
        },
    ```

    To run the script:

    ```
    npm run serve
    ```

01. ) Creating a script that runs our app with the webpack-dev-server, observe the "script section":

    ```
        "scripts": {
          "prestart": "node buildScripts/startMessage.js",
          "start": "npm-run-all --parallel security-check open:src",
          "open:src": "node buildScripts/srcServer.js",
          "security-check": "nsp check",
          "localtunnel": "lt --port 3000",
          "share": "npm-run-all --parallel open:src localtunnel",
          "clean": "rimraf build",
          "serve": "webpack-dev-server --config webpack.config.dev.js"
        },
    ```

    This script will delete all files in the build directory we use to compile our build files in.

    ```
    npm run clean
    ```

01. ) Our final scripts section in our package.json should look like this:

    ```
    {
      "name": "react-redux-weback2-starter",
      "version": "1.0.0",
      "description": "Starter kit with React, Redux and Webpack2",
      "scripts": {
        "prestart": "babel-node buildScripts/startMessage.js",
        "start": "npm-run-all --parallel security-check open:src",
        "open:src": "babel-node buildScripts/srcServer.js",
        "security-check": "nsp check",
        "localtunnel": "lt --port 3000",
        "share": "npm-run-all --parallel open:src localtunnel",
        "clean": "rimraf build",
        "serve": "webpack-dev-server"
      },
      "author": "Asim Abdelgadir",
      "license": "MIT",
      "dependencies": {
        "babel-polyfill": "6.8.0",
        "bootstrap": "3.3.6",
        "jquery": "2.2.3",
        "numeral": "^2.0.4",
        "react": "15.0.2",
        "react-dom": "15.0.2",
        "react-redux": "4.4.5",
        "react-router": "2.4.0",
        "react-router-redux": "4.0.4",
        "redux": "3.5.2",
        "redux-thunk": "2.0.1",
        "toastr": "2.1.2"
      },
      "devDependencies": {
        "babel-cli": "6.8.0",
        "babel-core": "6.8.0",
        "babel-loader": "6.2.4",
        "babel-plugin-react-display-name": "2.0.0",
        "babel-preset-es2015": "6.6.0",
        "babel-preset-react": "6.5.0",
        "babel-preset-react-hmre": "1.1.1",
        "babel-register": "6.8.0",
        "cheerio": "0.22.0",
        "colors": "1.1.2",
        "compression": "1.6.1",
        "cross-env": "1.0.7",
        "css-loader": "^0.23.1",
        "enzyme": "2.2.0",
        "eslint": "2.9.0",
        "eslint-plugin-import": "1.6.1",
        "eslint-plugin-react": "5.0.1",
        "eslint-watch": "2.1.11",
        "eventsource-polyfill": "0.9.6",
        "expect": "1.19.0",
        "express": "4.13.4",
        "extract-text-webpack-plugin": "1.0.1",
        "file-loader": "0.8.5",
        "html-webpack-plugin": "^2.28.0",
        "image-webpack-loader": "^3.2.0",
        "jsdom": "8.5.0",
        "localtunnel": "^1.8.2",
        "mocha": "2.4.5",
        "nock": "8.0.0",
        "npm-run-all": "1.8.0",
        "nsp": "^2.6.2",
        "open": "0.0.5",
        "react-addons-test-utils": "15.0.2",
        "redux-immutable-state-invariant": "1.2.3",
        "redux-mock-store": "1.0.2",
        "rimraf": "^2.5.2",
        "style-loader": "^0.13.1",
        "url-loader": "^0.5.7",
        "webpack": "^2.2.1",
        "webpack-dev-middleware": "^1.6.1",
        "webpack-dev-server": "^2.4.1",
        "webpack-hot-middleware": "^2.10.0",
        "webpack-md5-hash": "^0.0.5"
      },
      "repository": {
        "type": "git",
        "url": "https://github.com/zonender/react-redux-weback2-starter"
      }
    }
    ```
> **_//==============================================================\\_**
>
> **_CONFIGURING ESLINT_**
>
> **_\\==============================================================//_**

01. ) Create a .eslintrc.json file in the root with the following code: 

    ```
    {
      "root": true,
      "extends": [
        "eslint:recommended",
        "plugin:import/errors",
        "plugin:import/warnings"
      ],
      "parserOptions": {
        "ecmaVersion": 7,
        "sourceType": "module"
      },
      "env": {
        "browser": true,
        "node": true,
        "mocha": true
      },
      "rules": {
        "no-console": 1
      }
    }
    ```

01. ) Then write the following npm script:

    ```
    "scripts": {
      "prestart": "babel-node buildScripts/startMessage.js",
      "start": "npm-run-all --parallel security-check open:src",
      "open:src": "babel-node buildScripts/srcServer.js",
      "security-check": "nsp check",
      "localtunnel": "lt --port 3000",
      "share": "npm-run-all --parallel open:src localtunnel",
      "clean": "rimraf build",
      "serve": "webpack-dev-server",
      "lint": "esw webpack.config.* src buildScripts --color",
      "lint:watch": "npm run lint -- --watch"
    },
    ```

    make sure to disable any linting features your editor may have, otherwise you run the risk of overriding your linting rules with those of the editor's

01. ) We can even have eslint run in watch mode when we run "npm start":

    ```
    "scripts": {
      "prestart": "babel-node buildScripts/startMessage.js",
      "start": "npm-run-all --parallel security-check open:src",
      "open:src": "babel-node buildScripts/srcServer.js",
      "security-check": "nsp check",
      "localtunnel": "lt --port 3000",
      "share": "npm-run-all --parallel open:src localtunnel",
      "clean": "rimraf build",
      "serve": "webpack-dev-server",
      "lint": "esw webpack.config.* src buildScripts --color",
      "lint:watch": "npm run lint -- --watch"
    },
    ```

    make sure to disable any linting features your editor may have, otherwise you run the risk of overriding your linting rules with those of the editor's

> **_//==============================================================\\_**
>
> **_Tweaking WEBPACK.CONFIG.DEV.JS and Creating WEBPACK.CONFIG.PROD.JS_**
>
> **_\\==============================================================//_**

It is good proctise to have two separate webpack.config files, one for the dev env and the other for the prod env.

01. ) Modify the webpack.config.dev.js file as follows:

    ```
    const webpack = require('webpack');
    const path = require('path');
    const htmlWebpackPlugin = require('html-webpack-plugin');

    const config = {
      //The entry point for the bundle.
      entry: {
        bundle: path.resolve(__dirname, 'src/index')
      },
      output: {
        path: path.join(__dirname, 'build'),
        publicPath: '/',
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            use: 'babel-loader', //here we are selecting the loader
            test: /\.js$/, //and here we specify which file the loader will process
            exclude: /node_modules/
          },
          {
            test: /\.css$/,
            use: ['style-loader', 'css-loader']
          },
          {
            test: /\.(jpe?g|jpg|png|gif|svg)$/,
            use: [
              {
                loader: 'url-loader'
              },
              'image-webpack-loader'
            ]
          }
        ]
      },
      plugins: [
          //this plugin will insert the script tags for bundle.js and vendor.js in our index.html
          new htmlWebpackPlugin({
                template: 'src/index.html' //if we do not specifiy a template, it will use the default one
          }),
          new webpack.LoaderOptionsPlugin({
            options: {
                noInfo: false,
                debug: true,
                devtool: 'inline-source-map',
                target: 'web'
            }
          })
      ]
    };

    module.exports = config;
    ```

01. ) Create a production webpack config file named: webpack.config.prod.js with the following code:

    ```
    const webpack = require('webpack');
    const path = require('path');
    const htmlWebpackPlugin = require('html-webpack-plugin');

    //our app third party dependencies
    const VENDOR_LIBS = [
          'babel-polyfill', 'bootstrap', 'jquery', 'numeral', 'react', 'react-dom', 'react-redux',
          'react-router', 'react-router-redux', 'redux', 'redux-thunk', 'toastr'
    ];

    const config = {
      entry: {
        bundle: './src/index.js',
        vendor: VENDOR_LIBS
      },
      output: {
        path: path.join(__dirname, 'dist'),
        filename: '[name][chunkhash].js'
        // publicPath: 'build/'
      },
      module: {
        rules: [
          {
            use: 'babel-loader', //here we are selecting the loader
            test: /\.js$/, //and here we specify which file the loader will process
            exclude: /node_modules/
          },
          {
            test: /\.css$/,
            use: ['style-loader', 'css-loader']
          },
          {
            test: /\.(jpe?g|png|gif|svg)$/,
            use: [
              {
                loader: 'url-loader',
                options: { limit: 40000 }
              },
              'image-webpack-loader'
            ]
          }
        ]
      },
      plugins: [
          //this plugin will make sure there is no duplicate modules between vendor.js and bundle.js
          // if there are it will remove them from bundle.js and put them in vendor.js
          new webpack.optimize.CommonsChunkPlugin({
                names: ['vendor', 'manifest']
          }),
          //this plugin will insert the script tags for bundle.js and vendor.js in our index.html
          new htmlWebpackPlugin({
                template: 'src/index.html' //if we do not specifiy a template, it will use the default one
          }),
          new webpack.DefinePlugin({
            'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV)
          })
        ]
    };

    module.exports = config;
    ```
> **_//==============================================================\\_**
>
> **_Creating a webpack build for production_**
>
> **_\\==============================================================//_**

01. ) Create a build.js file under the buildScripts directory with the following code:

    ```
    /*eslint-disable no-console */
    import webpack from 'webpack';
    import webpackConfig from '../webpack.config.prod';
    import chalk from 'chalk';

    //this is important if you create a dev specific configuration for babel,
    //other libraries might look for this env variable to determine how they get built.
    process.env.NODE_ENV = 'production';

    console.log(chalk.blue('Generating minified bundle for production. This will take a moment...'));

    webpack(webpackConfig).run((err, stats) => {
      if (err) { // so a fatal error occurred. Stop here.
        console.log(chalk.red(err));
        return 1;
      }

      //and these are just warnings errors and stats displayed to the command line:
      const jsonStats = stats.toJson();

      if (jsonStats.hasErrors) {
        return jsonStats.errors.map(error => console.log(chalk.red(error)));
      }

      if (jsonStats.hasWarnings) {
        console.log(chalk.yellow('Webpack generated the following warnings: '));
        jsonStats.warnings.map(warning => console.log(chalk.yellow(warning)));
      }

      console.log(`Webpack stats: ${stats}`);

      // if we got this far, the build succeeded.
      console.log(chalk.green('Your app has been built for production and written to /dist!'));

      return 0;
    });
    ```

01. ) Setup an automated production build:

  01. ) Create a file named "distServer.js" in the buildScripts folder and add this code to it:

      ```
    //this is all we need for our dist server to serve our app locally for dubugging,
    //this is NOT for production, this is just to see how the app looks like on the local machine,
    //and to confirm it works locally.
    //typically these files should be uploaded to some host that will serve them through the internet.
    import express from 'express';
    import path from 'path';
    import open from 'open';
    //we will remove any call for webpack since we will no longer going to be
    //interacting with webpack for our dist server, we are going to be serving the statis
    //built files
    // import webpack from 'webpack';
    // import config from '../webpack.config.dev';

    const port = 3000;
    const app = express();

    //also we should enable gzip compression for our dist server
    app.use(compression());
    //we will have to add support for express for serving static files:
    app.use(express.static('dist'));

    //also remove the call to the compiler
    // const compiler = webpack(config);

    //also remove the call to configue webpack middleware
    // app.use(require('webpack-dev-middleware')(compiler, {
    //   noInfo: true,
    //   publicPath: config.output.publicPath
    // }));

    //and for prod we will be serving html from the dist folder not the src folder
    app.get('/', function(req, res) {
      res.sendFile(path.join(__dirname, '../dist/index.html'));
    });

    app.listen(port, function(err) {
      if (err) {
        console.log(err);
      } else {
        open('http://localhost:' + port);
      }
    });
      ```

      Just like we have a srcServer to serve our src folder, we now have a distServer to serve our dist folder.

  01. ) Create the npm scripts to create our build:

      ```
      "scripts": {
        "prestart": "babel-node buildScripts/startMessage.js",
        "start": "npm-run-all --parallel security-check open:src",
        "open:src": "babel-node buildScripts/srcServer.js",
        "security-check": "nsp check",
        "localtunnel": "lt --port 3000",
        "share": "npm-run-all --parallel open:src localtunnel",
        "clean": "rimraf build",
        "serve": "webpack-dev-server",
        "lint": "esw webpack.config.* src buildScripts --color; exit 0",
        "lint:watch": "npm run lint -- --watch",
        "clean-dist": "rimraf ./dist && mkdir dist",
        "prebuild": "npm-run-all clean-dist lint",
        "build": "babel-node buildScripts/build.js",
        "postbuild": "babel-node buildScripts/distServer.js"
      },
      ```
      To test this run:

      ```
      npm run build
      ```

> **_//==============================================================\\_**
>
> **_Extracting CSS from your bundled JS AND Creating sourcemaps_**
>
> **_\\==============================================================//_**

Currently our css is configured to be bundled within our bundled js, but sometimes you might want to extract css out of the bundled js, for example you can 
utilize cache busting techniques we are using with other files, also If your total stylesheet volume is big, it will be faster because the CSS bundle is loaded 
in parallel to the JS bundle, to extract css we will use the "ExtractTextPlugin" in our webpack.config.prod.js file, here is the modified file:

```
const webpack = require('webpack');
const path = require('path');
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const htmlWebpackPlugin = require('html-webpack-plugin');

//our app third party dependencies
const VENDOR_LIBS = [
      'babel-polyfill', 'bootstrap', 'jquery', 'numeral', 'react', 'react-dom', 'react-redux',
      'react-router', 'react-router-redux', 'redux', 'redux-thunk', 'toastr'
];

const config = {
  devtool: 'source-map',
  entry: {
    bundle: './src/index.js',
    vendor: VENDOR_LIBS
  },
  output: {
    path: path.join(__dirname, 'dist'),
    filename: '[name][chunkhash].js'
    // publicPath: 'build/'
  },
  module: {
    rules: [
      {
        use: 'babel-loader', //here we are selecting the loader
        test: /\.js$/, //and here we specify which file the loader will process
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        loader:  ExtractTextPlugin.extract({loader: 'css-loader?importLoaders=1'})
      },
      {
        test: /\.(jpe?g|png|gif|svg)$/,
        use: [
          {
            loader: 'url-loader',
            options: { limit: 40000 }
          },
          'image-webpack-loader'
        ]
      }
    ]
  },
  plugins: [
      // this will grap any css file produced by the css-loader and insert it into the style.css file
      new ExtractTextPlugin({
      filename: '[name][chunkhash].css',
      allChunks: true,
      }),
      //this plugin will make sure there is no duplicate modules between vendor.js and bundle.js 
      //if there are it will remove them from bundle.js and put them in vendor.js
      new webpack.optimize.CommonsChunkPlugin({
            names: ['vendor', 'manifest']
      }),
      //this plugin will insert the script tags for bundle.js and vendor.js in our index.html
      new htmlWebpackPlugin({
            template: 'src/index.html' //if we do not specifiy a template, it will use the default one
      }),
      new webpack.DefinePlugin({
        'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV)
      })
    ]
};

module.exports = config;
```

References:
https://www.npmjs.com/package/@taion/extract-text-webpack-plugin

> **_//==============================================================\\_**
>
> **_Creating NPM Deployment Scripts to deploy to Surge_**
>
> **_\\==============================================================//_**

To deploy the app to surge, we first have to install Surge, which is already installed, we just have to write the following npm script (deploy):

```
  "scripts": {
    "prestart": "babel-node buildScripts/startMessage.js",
    "start": "npm-run-all --parallel security-check open:src",
    "open:src": "babel-node buildScripts/srcServer.js",
    "security-check": "nsp check",
    "localtunnel": "lt --port 3000",
    "share": "npm-run-all --parallel open:src localtunnel",
    "clean": "rimraf build",
    "serve": "webpack-dev-server",
    "lint": "esw webpack.config.* src buildScripts --color",
    "lint:watch": "npm run lint -- --watch",
    "clean-dist": "rimraf ./dist && mkdir dist",
    "prebuild": "npm-run-all clean-dist lint",
    "build": "babel-node buildScripts/build.js",
    "postbuild": "babel-node buildScripts/distServer.js",
    "deploy": "surge ./dist"
  },
```

Then we have to create a build by runing "npm run build" to have something to deploy.

Finally run:

```
npm run deploy
```

You should see the following:

```
> surge ./dist


    Surge - surge.sh

              email: acsaasim@hotmail.com
              token: *****************
       project path: ./dist
               size: 12 files, 3.4 MB
             domain: dead-banana.surge.sh
```

Press enter, to complete the deployment to surge:

```
             upload: [====================] 100%, eta: 0.0s
   propagate on CDN: [====================] 100%
               plan: Free
              users: acsaasim@hotmail.com
         IP Address: 45.55.110.124

    Success! Project is published and running at dead-banana.surge.sh
```

Done! you can now visit the url provided above to visit your live app.

> **_//==============================================================\\_**
>
> **_Rewriting webpack config files in ES6_**
>
> **_\\==============================================================//_**

webpack.config.dev.js was written in CommonJS:

```
const webpack = require('webpack');
const path = require('path');
const htmlWebpackPlugin = require('html-webpack-plugin');

const config = {
  //The entry point for the bundle.
  entry: {
    bundle: path.resolve(__dirname, 'src/index')
  },
  output: {
    path: path.join(__dirname, 'dist'),
    publicPath: '/',
    filename: 'bundle.js'
  },
  module: {
    rules: [
      {
        use: 'babel-loader', //here we are selecting the loader
        test: /(\.js|\.jsx)$/, //and here we specify which file the loader will process
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.(jpe?g|jpg|png|gif|svg)$/,
        use: [
          {
            loader: 'url-loader'
          },
          'image-webpack-loader'
        ]
      }
    ]
  },
  plugins: [
      //this plugin will insert the script tags for bundle.js and vendor.js in our index.html
      new htmlWebpackPlugin({
            template: 'src/index.html' //if we do not specifiy a template, it will use the default one
      }),
      new webpack.LoaderOptionsPlugin({
        options: {
            noInfo: false,
            debug: true,
            devtool: 'inline-source-map',
            target: 'web'
        }
      })
  ]
};

module.exports = config;
```

Rewritten in ES6 it becomes:

```
import webpack from 'webpack';
import path from 'path';
import htmlWebpackPlugin from 'html-webpack-plugin';

export default {
  //The entry point for the bundle.
  entry: {
    bundle: path.resolve(__dirname, 'src/index')
  },
  output: {
    path: path.join(__dirname, 'dist'),
    publicPath: '/',
    filename: 'bundle.js'
  },
  module: {
    rules: [
      {
        use: 'babel-loader', //here we are selecting the loader
        test: /(\.js|\.jsx)$/, //and here we specify which file the loader will process
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.(jpe?g|jpg|png|gif|svg)$/,
        use: [
          {
            loader: 'url-loader'
          },
          'image-webpack-loader'
        ]
      }
    ]
  },
  plugins: [
      //this plugin will insert the script tags for bundle.js and vendor.js in our index.html
      new htmlWebpackPlugin({
            template: 'src/index.html' //if we do not specifiy a template, it will use the default one
      }),
      new webpack.LoaderOptionsPlugin({
        options: {
            noInfo: false,
            debug: true,
            devtool: 'inline-source-map',
            target: 'web'
        }
      })
  ]
};
```

And webpack.config.prod.js in CommonJS looked like this:

```
const webpack = require('webpack');
const path = require('path');
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const htmlWebpackPlugin = require('html-webpack-plugin');

//our app third party dependencies
const VENDOR_LIBS = [
      'babel-polyfill', 'bootstrap', 'jquery', 'numeral', 'react', 'react-dom', 'react-redux',
      'react-router', 'react-router-redux', 'redux', 'redux-thunk', 'toastr'
];

const config = {
  devtool: 'source-map',
  entry: {
    bundle: './src/index.js',
    vendor: VENDOR_LIBS
  },
  output: {
    path: path.join(__dirname, 'dist'),
    filename: '[name][chunkhash].js'
    // publicPath: 'build/'
  },
  module: {
    rules: [
      {
        use: 'babel-loader', //here we are selecting the loader
        test: /(\.js|\.jsx)$/, //and here we specify which file the loader will process
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        loader:  ExtractTextPlugin.extract({loader: 'css-loader?importLoaders=1'})
      },
      {
        test: /\.(jpe?g|png|gif|svg)$/,
        use: [
          {
            loader: 'url-loader',
            options: { limit: 40000 }
          },
          'image-webpack-loader'
        ]
      }
    ]
  },
  plugins: [
      // this will grap any css file produced by the css-loader and insert it into the style.css file
      new ExtractTextPlugin({
      filename: '[name][chunkhash].css',
      allChunks: true,
      }),
      //this plugin will make sure there is no duplicate modules between vendor.js and bundle.js
      // if there are it will remove them from bundle.js and put them in vendor.js
      new webpack.optimize.CommonsChunkPlugin({
            names: ['vendor', 'manifest']
      }),
      //this plugin will insert the script tags for bundle.js and vendor.js in our index.html
      new htmlWebpackPlugin({
            template: 'src/index.html' //if we do not specifiy a template, it will use the default one
      }),
      new webpack.DefinePlugin({
        'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV)
      })
    ]
};

module.exports = config;
```

After rewriting it in ES6 it becomes:

```
import webpack from 'webpack';
import path from 'path';
import ExtractTextPlugin from 'extract-text-webpack-plugin';
import htmlWebpackPlugin from 'html-webpack-plugin';

//our app third party dependencies
const VENDOR_LIBS = [
      'babel-polyfill', 'bootstrap', 'jquery', 'numeral', 'react', 'react-dom', 'react-redux',
      'react-router', 'react-router-redux', 'redux', 'redux-thunk', 'toastr'
];

export default {
  devtool: 'source-map',
  entry: {
    bundle: './src/index.js',
    vendor: VENDOR_LIBS
  },
  output: {
    path: path.join(__dirname, 'dist'),
    filename: '[name][chunkhash].js'
    // publicPath: 'build/'
  },
  module: {
    rules: [
      {
        use: 'babel-loader', //here we are selecting the loader
        test: /(\.js|\.jsx)$/, //and here we specify which file the loader will process
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        loader:  ExtractTextPlugin.extract({loader: 'css-loader?importLoaders=1'})
      },
      {
        test: /\.(jpe?g|png|gif|svg)$/,
        use: [
          {
            loader: 'url-loader',
            options: { limit: 40000 }
          },
          'image-webpack-loader'
        ]
      }
    ]
  },
  plugins: [
      // this will grap any css file produced by the css-loader and insert it into the style.css file
      new ExtractTextPlugin({
      filename: '[name][chunkhash].css',
      allChunks: true,
      }),
      //this plugin will make sure there is no duplicate modules between vendor.js and bundle.js
      // if there are it will remove them from bundle.js and put them in vendor.js
      new webpack.optimize.CommonsChunkPlugin({
            names: ['vendor', 'manifest']
      }),
      //this plugin will insert the script tags for bundle.js and vendor.js in our index.html
      new htmlWebpackPlugin({
            template: 'src/index.html' //if we do not specifiy a template, it will use the default one
      }),
      new webpack.DefinePlugin({
        'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV)
      })
    ]
};
```

> **_//==============================================================\\_**
>
> **_Webpack and hot reloading_**
>
> **_\\==============================================================//_**

To use hot reloading out of the box with webpack dev server you will have to start the app using webpack-dev-server, in our case we use the following script:

```
npm run serve
```

and this is the definition of the underlying script in package.json:

```
"serve": "webpack-dev-server --open --config webpack.config.dev.js",
```

IMPORTANT NOTE: unfortunately your webpack.config files must be written in commonJS in order for webpack-dev-server to work, if you write them in ES6 you will get the following error:

```
$ webpack-dev-server --config webpack.config.dev.js
C:\Users\acsaa\Desktop\Dev\react-redux-weback2-starter\webpack.config.dev.js:1
(function (exports, require, module, __filename, __dirname) { import webpack from 'webpack';
                                                              ^^^^^^
SyntaxError: Unexpected token import
    at Object.exports.runInThisContext (vm.js:73:16)
    at Module._compile (module.js:543:28)
    at Object.Module._extensions..js (module.js:580:10)
    at Module.load (module.js:488:32)
    at tryModuleLoad (module.js:447:12)
    at Function.Module._load (module.js:439:3)
    at Module.require (module.js:498:17)
    at require (internal/module.js:20:19)
    at requireConfig (C:\Users\acsaa\AppData\Roaming\npm\node_modules\webpack\bin\convert-argv.js:96:18)
    at C:\Users\acsaa\AppData\Roaming\npm\node_modules\webpack\bin\convert-argv.js:109:17
```

Now you should be able to save content and see the changes on the broweser without reloading.

> **_//==============================================================\\_**
>
> **_Configuring Express with Webpack and hot reloading_**
>
> **_\\==============================================================//_**

To acheive this we must add the following lines to our buildScripts/srcServer.js file:

```
import express from 'express';
import path from 'path';
import open from 'open';
import webpack from 'webpack';
import config from '../webpack.config.dev';

const port = 3000;
const app = express();
const compiler = webpack(config);

//hot reloading
app.use(require('webpack-dev-middleware')(compiler, {
  noInfo: true,
  publicPath: config.output.publicPath
}));

//hot reloading
app.use(require('webpack-hot-middleware')(compiler));

app.get('*', function(req, res) {
  res.sendFile(path.join(__dirname, '../src/index.html'));
});

app.listen(port, function(err) {
  if (err) {
    console.log(err);
  } else {
    open('http://localhost:' + port);
  }
});
```

We also have to edit our webpack,config file as follows:

```
const webpack = require('webpack');
const path = require('path');
const htmlWebpackPlugin = require('html-webpack-plugin');

const config = {
  //The entry point for the bundle.
  devtool: 'cheap-module-eval-source-map',
  entry: {
    //hot reloading
    bundle: [
      'eventsource-polyfill',
      'webpack-hot-middleware/client?reload=true',
      path.resolve(__dirname, 'src/index')
    ]
    //without hot reloading
    // bundle: path.resolve(__dirname, 'src/index')
  },
  output: {
    path: path.join(__dirname, 'dist'),
    publicPath: '/',
    filename: 'bundle.js'
  },
  module: {
    rules: [
      {
        use: ['babel-loader'], //here we are selecting the loader
        test: /(\.js|\.jsx)$/, //and here we specify which file the loader will process
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.(jpe?g|jpg|png|gif|svg)$/,
        use: [
          {
            loader: 'url-loader'
          },
          'image-webpack-loader'
        ]
      }
    ]
  },
  plugins: [
      //hot reloading
      new webpack.HotModuleReplacementPlugin(),
      new webpack.NoEmitOnErrorsPlugin(),
      //this plugin will insert the script tags for bundle.js and vendor.js in our index.html
      new htmlWebpackPlugin({
            template: 'src/index.html' //if we do not specifiy a template, it will use the default one
      }),
      new webpack.LoaderOptionsPlugin({
        options: {
            noInfo: false,
            debug: true,
            devtool: 'inline-source-map',
            target: 'web'
        }
      })
  ]
};

module.exports = config;
```

> **_//==============================================================\\_**
>
> **_Configuring Express with Webpack and hot reloading for html files_**
>
> **_\\==============================================================//_**

You may have noticed that when changes are saved to our index.html hot reloading does not work, to have hot reloading available to all our html files, follow these two steps:

01. ) We already installed raw-loader under our dev dependencies, if it is not installed run:

```
npm install raw-loader --save-dev
```

01. ) Add the loader to our webpack.config.dev.js file by adding these lines:

```
      {
        test: /\.html$/,
        use: "raw-loader"
      },
```

So our webpack.config.dev.js becomes:

```
const webpack = require('webpack');
const path = require('path');
const htmlWebpackPlugin = require('html-webpack-plugin');

const config = {
  //The entry point for the bundle.
  watch: true,
  devtool: 'cheap-module-eval-source-map',
  entry: {
    //hot reloading
    bundle: [
      'eventsource-polyfill',
      'webpack-hot-middleware/client?reload=true',
      path.resolve(__dirname, 'src/index')
    ]
    //without hot reloading
    // bundle: path.resolve(__dirname, 'src/index')
  },
  output: {
    path: path.join(__dirname, 'dist'),
    publicPath: '/',
    filename: 'bundle.js'
  },
  module: {
    rules: [
      {
        use: ['babel-loader'], //here we are selecting the loader
        test: /(\.js|\.jsx)$/, //and here we specify which file the loader will process
        exclude: /node_modules/
      },
      {
        test: /\.html$/,
        use: "raw-loader"
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.(jpe?g|jpg|png|gif|svg)$/,
        use: [
          {
            loader: 'url-loader'
          },
          'image-webpack-loader'
        ]
      }
    ]
  },
  plugins: [
      //hr
      new webpack.HotModuleReplacementPlugin(),
      new webpack.NoEmitOnErrorsPlugin(),
      //this plugin will insert the script tags for bundle.js and vendor.js in our index.html
      new htmlWebpackPlugin({
            template: 'src/index.html' //if we do not specifiy a template, it will use the default one
      }),
      new webpack.LoaderOptionsPlugin({
        options: {
            noInfo: false,
            debug: true,
            devtool: 'inline-source-map',
            target: 'web'
        }
      })
  ]
};

module.exports = config;
```

01. ) Import our index.html in ou entry point file: index.js as follows:

```
import indexhtml from './index.html';
```

So our index.js file becomes:

```
/* global System */ //this is for eslint to allow the use of System.import
import indexhtml from './index.html';
import talk from './talkToConsole';
console.log(talk(1, 2));

const button = document.createElement('button');
button.innerText = 'Click Me To Display Images';
button.onclick = () => {
    System.import('./image_viewer').then(module => {
        module.default();
    });
};

document.body.appendChild(button);
```

Now run the app:

```
npm start -s
```

Save some changes to index.html and observe, the changes are automatically reflected without reloading the browser.

Reference: http://stackoverflow.com/questions/33183931/how-to-watch-index-html-using-webpack-dev-server-and-html-webpack-plugin

> **_//==============================================================\\_**
>
> **_Adding a React Components to the App_**
>
> **_\\==============================================================//_**

We are going to add a few react components to this app:

01. ) Make sure to include all the following dependencies in the app by updating the package.json file as follows and save it:

    ```
    {
      "name": "react-redux-weback2-starter",
      "version": "1.0.0",
      "description": "Starter kit with React, Redux and Webpack2",
      "scripts": {
        "prestart": "babel-node buildScripts/startMessage.js",
        "start": "npm-run-all --parallel security-check open:src",
        "open:src": "babel-node buildScripts/srcServer.js",
        "security-check": "nsp check",
        "localtunnel": "lt --port 3000",
        "share": "npm-run-all --parallel open:src localtunnel",
        "clean": "rimraf build",
        "serve": "webpack-dev-server --open --config webpack.config.dev.js",
        "lint": "esw webpack.config.* src buildScripts --color",
        "lint:watch": "npm run lint -- --watch",
        "clean-dist": "rimraf ./dist && mkdir dist",
        "prebuild": "npm-run-all clean-dist lint",
        "build": "babel-node buildScripts/build.js",
        "postbuild": "babel-node buildScripts/distServer.js",
        "deploy": "surge ./dist"
      },
      "author": "Asim Abdelgadir",
      "license": "MIT",
      "dependencies": {
        "babel-polyfill": "6.8.0",
        "bootstrap": "3.3.6",
        "jquery": "2.2.3",
        "numeral": "^2.0.4",
        "react": "15.0.2",
        "react-dom": "15.0.2",
        "react-redux": "4.4.5",
        "react-router": "2.4.0",
        "react-router-redux": "4.0.4",
        "redux": "3.5.2",
        "redux-thunk": "2.0.1",
        "toastr": "2.1.2"
      },
      "devDependencies": {
        "babel-cli": "6.8.0",
        "babel-core": "6.8.0",
        "babel-loader": "6.2.4",
        "babel-plugin-react-display-name": "2.0.0",
        "babel-plugin-react-transform": "^2.0.0-beta1",
        "babel-preset-es2015": "6.6.0",
        "babel-preset-react": "6.5.0",
        "babel-preset-react-hmre": "1.1.1",
        "babel-register": "6.8.0",
        "cheerio": "0.22.0",
        "colors": "1.1.2",
        "compression": "1.6.1",
        "cross-env": "1.0.7",
        "css-loader": "^0.23.1",
        "enzyme": "2.2.0",
        "eslint": "^3.17.0",
        "eslint-plugin-import": "^2.2.0",
        "eslint-plugin-react": "^6.10.0",
        "eslint-watch": "^2.1.13",
        "eventsource-polyfill": "0.9.6",
        "expect": "1.19.0",
        "express": "4.13.4",
        "extract-text-webpack-plugin": "^2.1.0",
        "file-loader": "0.8.5",
        "html-webpack-plugin": "^2.28.0",
        "image-webpack-loader": "^3.2.0",
        "install": "^0.8.7",
        "jsdom": "8.5.0",
        "localtunnel": "^1.8.2",
        "mocha": "2.4.5",
        "nock": "8.0.0",
        "npm": "^4.3.0",
        "npm-run-all": "1.8.0",
        "nsp": "^2.6.2",
        "open": "0.0.5",
        "raw-loader": "^0.5.1",
        "react-addons-test-utils": "15.0.2",
        "react-hot-loader": "^3.0.0-beta.6",
        "react-transform-hmr": "^1.0.4",
        "redux-immutable-state-invariant": "1.2.3",
        "redux-mock-store": "1.0.2",
        "rimraf": "^2.5.2",
        "style-loader": "^0.13.1",
        "surge": "^0.18.0",
        "url-loader": "^0.5.7",
        "webpack": "^2.2.1",
        "webpack-dev-middleware": "^1.10.1",
        "webpack-dev-server": "^2.4.1",
        "webpack-hot-middleware": "^2.17.1",
        "webpack-md5-hash": "^0.0.5"
      },
      "repository": {
        "type": "git",
        "url": "https://github.com/zonender/react-redux-weback2-starter"
      }
    }
    ```

01. ) Run:

    ```
    npm install
    ```

01. ) Update the webpack.config file as follows and save it:

    ```
    const webpack = require('webpack');
    const path = require('path');
    const htmlWebpackPlugin = require('html-webpack-plugin');

    const config = {
      //The entry point for the bundle.
      watch: true,
      devtool: 'cheap-module-eval-source-map',
      entry: {
        //hot reloading
        bundle: [
          'eventsource-polyfill', 
          'webpack-hot-middleware/client?reload=true', 
          path.resolve(__dirname, 'src/index')
        ]
        //without hot reloading
        // bundle: path.resolve(__dirname, 'src/index')
      },
      output: {
        path: path.join(__dirname, 'dist'),
        publicPath: '/',
        filename: 'bundle.js'
      },
      module: {
        rules: [
          {
            use: ['babel-loader'], //here we are selecting the loader
            test: /(\.js|\.jsx)$/, //and here we specify which file the loader will process
            exclude: /node_modules/
          },
          {
            test: /\.html$/,
            use: "raw-loader"
          },
          {
            test: /\.css$/,
            use: ['style-loader', 'css-loader']
          },
          {
            test: /\.(jpe?g|jpg|png|gif|svg)$/,
            use: [
              {
                loader: 'url-loader'
              },
              'image-webpack-loader'
            ]
          },
          { test: /\.(png|woff|woff2|eot|ttf|svg)$/, use: 'url-loader?limit=100000' }
        ]
      },
      plugins: [
          //hr
          new webpack.HotModuleReplacementPlugin(),
          new webpack.NoEmitOnErrorsPlugin(),
          //this plugin will insert the script tags for bundle.js and vendor.js in our index.html
          new htmlWebpackPlugin({
                template: 'src/index.html' //if we do not specifiy a template, it will use the default one
          }),
          new webpack.LoaderOptionsPlugin({
            options: {
                noInfo: false,
                debug: true,
                devtool: 'inline-source-map',
                target: 'web'
            }
          })
      ]
    };

    module.exports = config;
    ```

01. ) Update src/index.js as follows and save it:

    ```
    // /* global System */ //this is for eslint to allow the use of System.import
    import indexhtml from './index.html';
    import talk from './talkToConsole';
    console.log(talk(1, 2));

    const button = document.createElement('button');
    button.innerText = 'Click Me To Display Images';
    button.onclick = () => {
        System.import('./image_viewer').then(module => {
            module.default();
        });
    };

    document.body.appendChild(button);

    import 'babel-polyfill';
    import React from 'react';
    import { render } from 'react-dom';
    import { Router, browserHistory } from 'react-router';
    import routes from './routes';
    import './styles/style.css';
    import '../node_modules/bootstrap/dist/css/bootstrap.min.css';

    render(
      <Router history={browserHistory} routes={routes} />,
      document.getElementById('app')
    );
    ```

01. ) Update src/index.html as follows and save it:

    ```
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <title></title>
        <meta charset="UTF-8">
      </head>
      <body>
        <h1>Hello World!</h1>
        <div id="app"></div>
      </body>
    </html>
    ```

01. ) Update src/styles/style.css as follows and save it:

    ```
    img {
        border: 10px solid red;
    }

    #app {
      font: 14px 'Helvetica Neue', Helvetica, Arial, sans-serif;
      color: #4d4d4d;
      min-width: 550px;
      max-width: 850px;
      margin: 0 auto;
    }

    a.active {
      color: orange;
    }

    nav {
      padding-top: 20px;
    }
    ```

01. ) Create the file src/routes.js and save it:

    ```
    import React from 'react';
    import { Route, IndexRoute } from 'react-router';
    import App from './components/App';
    import HomePage from './components/home/HomePage';
    import AboutPage from './components/about/AboutPage';
    import CoursesPage from './components/course/CoursesPage';

    export default (
      <Route path="/" component={App}>
        <IndexRoute component={HomePage} />
        <Route path="courses" component={CoursesPage} />
        <Route path="about" component={AboutPage} />
      </Route>
    );
    ```

01. ) Create the file components/about/AboutPage.js and save it:

    ```
    import React from 'react';

    class AboutPage extends React.Component {
      render() {
        return (
          <div>
            <h1>About</h1>
            <p>Lorum lkjsdf sdfasdf sdfsadf asdfasdf asdfasdf asdfasdf asdfasdf.</p>
          </div>
        );
      }
    }

    export default AboutPage;
    ```

01. ) Create the file components/common/Header.js and save it:

    ```
    import React, {PropTypes} from 'react';
    import { Link, IndexLink } from 'react-router';

    const Header = () => {
      return (
        <nav>
          <IndexLink to="/" activeClassName="active">Home</IndexLink>
          {" | "}
          <Link to="/courses" activeClassName="active">Courses</Link>
          {" | "}
          <Link to="/about" activeClassName="active">About</Link>
        </nav>
      );
    };

    export default Header;
    ```

01. ) Create the file components/course/CoursesPage.js and save it:

    ```
    import React, {PropTypes} from 'react';

    class CoursesPage extends React.Component {
      render() {
        return (
          <div>
            <h1>Courses</h1>
          </div>
        );
      }
    }

    export default CoursesPage;
    ```

01. ) Create the file components/home/HomePage.js and save it:

    ```
    import React from 'react';
    import {Link} from 'react-router';

    class HomePage extends React.Component {
      render() {
        return (
          <div className="jumbotron">
            <h1>Pluralsight Admin</h1>
            <p>Lorum lkjsdf sdfasdf sdfsadf asdfasdf asdfasdf asdfasdf asdfasdf.</p>
            <Link to="about" className="btn btn-primary btn-lg">Learn More Here</Link>
          </div>
        );
      }
    }

    export default HomePage;
    ```

01. ) Create the file components/App.js and save it:

    ```
    import React, {PropTypes} from 'react';
    import Header from './common/Header';

    class App extends React.Component {
      render() {
        return (
          <div className="container-fluid">
            <Header/>
            {this.props.children}
          </div>
        );
      }
    }

    App.propTypes = {
      children: PropTypes.object.isRequired
    };

    export default App;
    ```

01. ) Run the app:

    ```
    npm start
    ```

    or

    ```
    npm run serve
    ```

> **_//==============================================================\\_**
>
> **_Creating a simple form and binding data in ES6_**
>
> **_\\==============================================================//_**

We will demonstrate the first use of redux by adding a new course, to do that we will first create a container component, which is done via a form
 in which the course details are added, the best approach would be to create a separate component to hold our html, but for the sake of simplicity, we will
 add our form directly in our CoursePage component.

01. ) Open src/components/course/CoursesPage.js and add a constructor function to initialize state for the form in the constructor, again for simplicity we will assume a course has only a title for now:

    ```
    constructor(props, context) {
      super(props, context);

      this.state = {
        course: { title: null }
      };
    }
    ```

    So our src/components/course/CoursesPage.js becomes:

    ```
    import React, {PropTypes} from 'react';

    class CoursesPage extends React.Component {
      constructor(props, context) {
        super(props, context);

        this.state = {
        course: { title: null }
        };
      }

      render() {
        return (
          <div>
            <h1>Courses</h1>
          </div>
        );
      }
    }

    export default CoursesPage;
    ```

01. ) Lets add the form to the page by adding this html to the render function:

    ```
    <h2>Add Course</h2>
    <input
      type="text"
      onChange={this.onTitleChange}
      value={this.state.course.title} />

    <input
      type="submit"
      value="Save"
      onClick={this.onClickSave} />
    ``` 

    So our src/components/course/CoursesPage.js becomes:

    ```
    import React, {PropTypes} from 'react';

    class CoursesPage extends React.Component {
      constructor(props, context) {
        super(props, context);

        this.state = {
        course: { title: null }
        };
      }

      render() {
        return (
          <div>
            <h1>Courses</h1>
            <h2>Add Course</h2>
            <input
              type="text"
              onChange={this.onTitleChange}
              value={this.state.course.title} />

            <input
              type="submit"
              value="Save"
              onClick={this.onClickSave} />
          </div>
        );
      }
    }

    export default CoursesPage;
    ```

01. ) Lets create the functions this.onTitleChange:

    ```
    onTitleChange(event) {
      const course = this.state.course;
      course.title = event.target.value;
      this.setState({course: course});
    }
    ```

    So our src/components/course/CoursesPage.js becomes:

    ```
    import React, {PropTypes} from 'react';

    class CoursesPage extends React.Component {
      constructor(props, context) {
        super(props, context);

        this.state = {
        course: { title: "" } //setting this to null will raise an error, make sure you use an initial value with 
        //an empty string ""
        };
      }

      onTitleChange(event) {
      const course = this.state.course;
      course.title = event.target.value;
      this.setState({course: course});
      }

      render() {
        return (
          <div>
            <h1>Courses</h1>
            <h2>Add Course</h2>
            <input
              type="text"
              onChange={this.onTitleChange}
              value={this.state.course.title} />

            <input
              type="submit"
              value="Save"
              onClick={this.onClickSave} />
          </div>
        );
      }
    }

    export default CoursesPage;
    ```

01. ) Lets create the function this.onClickSave:

    ```
    onClickSave() {
      alert(`Saving ${this.state.course.title}`);
    }
    ```

    So our src/components/course/CoursesPage.js becomes:

    ```
    import React, {PropTypes} from 'react';

    class CoursesPage extends React.Component {
      constructor(props, context) {
        super(props, context);

        this.state = {
        course: { title: null }
        };
      }

      onTitleChange(event) {
      const course = this.state.course;
      course.title = event.target.value;
      this.setState({course: course});
      }

      onClickSave() {
      alert(`Saving ${this.state.course.title}`);
      }

      render() {
        return (
          <div>
            <h1>Courses</h1>
            <h2>Add Course</h2>
            <input
              type="text"
              onChange={this.onTitleChange}
              value={this.state.course.title} />

            <input
              type="submit"
              value="Save"
              onClick={this.onClickSave} />
          </div>
        );
      }
    }

    export default CoursesPage;
    ```

    Running the app now will throw the following error: "Uncaught TypeError: Cannot read property 'state' of undefined"

    Because the "this" keyword in the line: "const course = this.state.course;" in the function: "onTitleChange" actually referes to the function "onTitleChange" and not to the class "CoursesPage":

    ```
      onTitleChange(event) {
      const course = this.state.course;
      course.title = event.target.value;
      this.setState({course: course});
      }
    ```

    ,so the "this" context is wrong in our change handler, the function is inheriting the "this" context
    from the caller, which in this case the caller is the "onTitleChange" function.

    When using react's create class function, functions are autobound for you and you don't have to use "bind", however, react doesn't autobind in ES6 classes so we have to handle
    binding our selves.

    To fix this, lets bind the "this" context up in the constructor in the CoursesPage class, so we will add the following bind statements:

01. ) Now lets bind the data:

    ```
    this.onTitleChange = this.onTitleChange.bind(this);
    this.onClickSave = this.onClickSave.bind(this);
    ```

    So our src/components/course/CoursesPage.js becomes:

    ```
    import React, {PropTypes} from 'react';

    class CoursesPage extends React.Component {
      constructor(props, context) {
        super(props, context);

        this.state = {
        course: { title: "" } //setting this to null will raise an error, make sure you use an initial value with 
        //an empty string ""
        };

        this.onTitleChange = this.onTitleChange.bind(this);
        this.onClickSave = this.onClickSave.bind(this);
      }

      onTitleChange(event) {
      const course = this.state.course;
      course.title = event.target.value;
      this.setState({course: course});
      }

      onClickSave() {
      alert(`Saving ${this.state.course.title}`);
      }

      render() {
        return (
          <div>
            <h1>Courses</h1>
            <h2>Add Course</h2>
            <input
              type="text"
              onChange={this.onTitleChange}
              value={this.state.course.title} />

            <input
              type="submit"
              value="Save"
              onClick={this.onClickSave} />
          </div>
        );
      }
    }

    export default CoursesPage;
    ```

    so now we have bound them to the "this" of the CoursesPage component.

    We can also do the bind under the render function like this:

    ```
    onChange={this.onTitleChange.bind(this)}
    ```

    and 

    ```
    onClick={this.onClickSave.bind(this)}
    ```

    under the render function:

    ```
      render() {
        return (
          <div>
            <h1>Courses</h1>
            <h2>Add Course</h2>
            <input
              type="text"
              onChange={this.onTitleChange.bind(this)}
              value={this.state.course.title} />

            <input
              type="submit"
              value="Save"
              onClick={this.onClickSave.bind(this)} />
          </div>
        );
      }
    ```

    however, this will impact the performance, everytime you do a bind and render a new function will be created on each render, so always make sure to place your bind calls
    under the constructor of the component class.

    Now run the app, and you should get a popup message containing the text you entered.

> **_//==============================================================\\_**
>
> **_Creating our first action for Redux_**
>
> **_\\==============================================================//_**

We now have a form that is ready to send data, lets wire it up to Redux.

01. ) Create a folder to keep our Redux related files called src/actions:

    in the folder create the file src/actions/courseActions.js this file will hold our course related action creators.

01. ) Create the first action creator called createCourse by adding this code in the src/actions/courseActions.js file:

    ```
    export function createCourse(course) {
      return { type: 'CREATE_COURSE', course }
    }
    ```

> **_//==============================================================\\_**
>
> **_Creating our first reducer for Redux_**
>
> **_\\==============================================================//_**

Now that we created an action we need a function that will handle that action, and this is where reducers come into play, in Redux we handle actions with reducers, a reducer
is just a function that accepts a state and an action and then returns a new state.

01. ) Create a new directory called src/reducers.

01. ) Create a new file called src/reducers/courseReducer.js and in it put the following code:

    ```
    export default function courseReducer(state = [], action) {
      switch(action.type) {
        case 'CREATE_COURSE':
          return [...state,
            Object.assign({}, action.course)
          ];

        default:
          return state;
      }
    }
    ```

    The default state here: "state = []" has been set to an array because this reducer will handle our list of cources, and by setting this to an empty array, we are telling the reducer
    we are starting out with no courses.

    The switch statment will allow us to fork our logic based on the action we receive, specifically we will look at the action type, for now the only action we will handle is the
    "CREATE_COURSE" action, everytime you use a switch statement it is a good idea to have a default, because we could have multiple reducers handling different actions, and if this
    reducer isn't handling this specific action it should just return state.

    Then we will return a new array:
    
    ```
     return [...state,
      Object.assign({}, action.course)
    ];
    ```

     here we used the spread operator "...state" on our existing state and then we used "Object.assign" and pass it our target object which is an empty object in this case, then 
     pass it the course that is passed on our action, finally close out the array.

     The ES6 spread operator spreads the array as if we took all the values in it and defined them here: "...state" inline, so this "...state" ends up returning a new instance of our 
     state array, then I can use Object to create a deep copy of the course that is passed in, this way these two values together end up returning a new state that contains a new course
     that someone has just passed in via the action.

     In ES6 the spread operator along with object.assign are commonly used within reducers to create a copy of an array with extra values.

     Also note that you can replace the switch/case statements although they are quite common with if statements, if you prefer, even though in Redux we have only one store, reducers let us slice up the management of your store state changes into a number of separate functions, and that is why the switch/case statment is useful so we can say for these specific actionTypes, we want to perform some functions and for any that i don't define within the switch statment I just want tot return the existing state.

> **_//==============================================================\\_**
>
> **_Creating a root reducer_**
>
> **_\\==============================================================//_**

Redux supports multiple reducers and most apps will be using more than one reducer and hence the need for a rootReducer, we will only need a root reducer when we use more than one
reducer.

01. ) Create a new file called src/reducers/index.js, in it add the following code:

    ```
    import {combineReducers} from 'redux';
    import courses from './courseReducer';

    const rootReducer = combineReducers({
      courses //this is called a shorthand property name
    });

    export default rootReducer;
    ```

> **_//==============================================================\\_**
>
> **_Creating the store and instantiating the store and the provider_**
>
> **_\\==============================================================//_**

In redux there is only one store.

01. ) Create a folder called src/store

01. ) In the src/store folder create the file src/store/configureStore.js, now we can configure our redux store by adding the following code in it, when creating a store it is useful to define a function that configures the store, this way we can call this function in our application entry point, this way the store is configured when the app starts up:

    ```
    import {createStore} from 'redux';
    import rootReducer from '../reducers';

    export default function configureStore(initialState) {
      return createStore(rootReducer, initialState);
    }
    ```

    And this is all it takes to configure our store, the configureStore function should accept one parameter which is the initialState, this is a good way to initialize your store with some state especially when we are doing server side rendering, we will not be covering server side rendering here.

01. ) To enhance our store we will also add middleware:

    ```
    import {createStore, applyMiddleware} from 'redux';
    import rootReducer from '../reducers';
    import reduxImmutableStateInvariant from 'redux-immutable-state-invariant';

    export default function configureStore(initialState) {
      return createStore(
        rootReducer, 
        initialState,
        applyMiddleware(reduxImmutableStateInvariant())
        );
    }
    ```

01. ) Now that we have configured our configureStore function, we will put it to use in our application entry point, so here we will update our app entry point to work with redux, open the file src/index.js:

    ```
    import configureStore from './store/configureStore';

    const store = configureStore();
    ```

    If we were creating a server side redering app, we would also pass the initialState paramater to the configure store function like so:

    ```
    const store = configureStore(initialState);
    ```

    So the file should look like:

    ```
    // /* global System */ //this is for eslint to allow the use of System.import
    import indexhtml from './index.html';
    import talk from './talkToConsole';
    console.log(talk(1, 2));

    const button = document.createElement('button');
    button.innerText = 'Click Me To Display Images';
    button.onclick = () => {
        System.import('./image_viewer').then(module => {
            module.default();
        });
    };

    document.body.appendChild(button);

    import 'babel-polyfill';
    import React from 'react';
    import { render } from 'react-dom';
    import { Router, browserHistory } from 'react-router';
    import routes from './routes';
    import './styles/style.css';
    import '../node_modules/bootstrap/dist/css/bootstrap.min.css';
    import configureStore from './store/configureStore';

    const store = configureStore();

    render(
      <Router history={browserHistory} routes={routes} />,
      document.getElementById('app')
    );
    ```

01. ) We now have a configured instance of a store that we have set to a constant, to use it we need a companion library called "provider", it attaches the store to 
    our react container components:

    ```
    // /* global System */ //this is for eslint to allow the use of System.import
    import indexhtml from './index.html';
    import talk from './talkToConsole';
    import 'babel-polyfill';
    import React from 'react';
    import { render } from 'react-dom';
    import { Router, browserHistory } from 'react-router';
    import routes from './routes';
    import './styles/style.css';
    import '../node_modules/bootstrap/dist/css/bootstrap.min.css';
    import configureStore from './store/configureStore';
    import {provider} from 'react-redux';

    console.log(talk(1, 2));

    const button = document.createElement('button');
    button.innerText = 'Click Me To Display Images';
    button.onclick = () => {
        System.import('./image_viewer').then(module => {
            module.default();
        });
    };

    document.body.appendChild(button);

    const store = configureStore();

    render(
      <Provider store={store}>
        <Router history={browserHistory} routes={routes} />
      </Provider>,
      document.getElementById('app')
    );
    ```

> **_//==============================================================\\_**
>
> **_Connecting the store to react container components and dispatching an action_**
>
> **_\\==============================================================//_**

Most of the work we just did so far with redux is a one time setup, now we have all the redux infrastructure setup except for one remaining piece which is to update our 
coursePage component to work with redux, to do that we need to reference the connect function, the connect function is what we use to create react components that 
interact with redux, these are called container components.

01. ) Open the file src/components/course/CoursesPage.js and add the following code:

    ```
    import {connect} from 'react-redux';
    ```

    Then, instead of exporting a plain component we are going to export the component that is decorated by the react-redux connect function, the connect function is what we use to create components that interact with redux, going forward we will call these components container components.

    Instead of exporting the CoursesPage we will export the CoursesPage wrapped in a call to the connect function like this:

    ```
    export default connect(mapStateToProps, mapDispatchToProps)(CoursesPage);
    ```

    connect is a higher order component that is going to wrap our CoursesPage, connect takes two parameters, the fisrt mapStateToProps and the second mapDispatchToProps, each of these parameters are functions them selves.

    Notice how we placed the two perantheses side by side:

    ```
    export default connect(mapStateToProps, mapDispatchToProps)(CoursesPage);
    ```

    these are just two function calls, the connect function is returning a function, and that function ends up calling our container component "CoursesPage" with the result of th efirst function, to clarify this here is an alternative setup:

    ```
    const connectedStateAndProps = connect(mapStateToProps, mapDispatchToProps);
    export default connectedStateAndProps(CoursesPage);
    ```

    above we created an intermediate variable connectedStateAndProps, we called connect and passed it the parameters mapStateToProps and mapDispatchToProps and then we stored the result in connectedStateAndProps which is a function, then i can use that function "connectedStateAndProps" to call the CoursesPage.

    The first function we passed into the connect function as a parameter is the mapStateToProps, lets define it here:

    ```
    function mapStateToProps(state, ownProps) {
      return {
        courses
      };
    }
    ```

    mapStateToProps takes two parameters, "state" and "ownProps", inside the function we will define an object that returns the properties we would like to see exposed in our component, so when I say: "courses" under the return object, then I am saying I would like to be able to access my courses by saying this.props.courses here on this component:

    ```
    render() {
      return (
        <div>
          <h1>Courses</h1>
          <h2>Add Course</h2>
          <input
            type="text"
            onChange={this.onTitleChange}
            value={this.state.course.title} />

          <input
            type="submit"
            value="Save"
            onClick={this.onClickSave} />
        </div>
      );
    }
    ```

    now what we need to define is how to get that course data, the "state" parameter we passed in the mapStateToProps function represents the state that is within our redux store, to access this state will say: "courses: state.courses" like this:

    ```
    function mapStateToProps(state, ownProps) {
      return {
        courses: state.courses
      };
    }
    ```

    and now I am accessing the course data that is within our redux store, remember that this property here: "state.courses" under the return object is determined by the choice we made within our root reducer src/reducers/index.js.

    The second parameter mapStateToProps takes is the "ownProps" parameter which lets us access the props that are being attached to this component, that is why it is called ownProps because it is a reference to the component's own props, in this case it will be most useful for accessing routing related props injected by react routers, we are not going to need that at this point so we will discuss it more later.

    The second parameter passed to the connect function is mapDispatchToProps, this parameter is for deciding what actions you want to expose on your component, this is an optional parameter, so we can delete it for now. when we delete this parameter our component automatically gets a dispatch property attached to it and that is injected by connect, so if you don't put the mapDispatchToProps parameter in the connect function then you will be able to come up here in the component:

    ```
    render() {
      return (
        <div>
          <h1>Courses</h1>
          <h2>Add Course</h2>
          <input
            type="text"
            onChange={this.onTitleChange}
            value={this.state.course.title} />

          <input
            type="submit"
            value="Save"
            onClick={this.onClickSave} />
        </div>
      );
    }
    ```

    and say this.props.dispatch, dispatch is a function that allows you to fire off your actions, so we will be able to dispatch defferent actions that we have defined in the 
    src/actions/courseActions.js file, to be able to dispatch an action we need to go back to the top of the file CoursesPage.js because we need to create a reference to the createCourse action that we created earlier, so we will have to import it:

    ```
    import * as courseActions from '../../actions/courseActions';
    ```

    and that we have access to our createCourse action in our component we can now go ahead and update our onClickSave function by deleting the alert we placed earlier and add the following code:

    ```
    onClickSave() {
      this.props.dispatch();
    }
    ```

    so now we dispatched our first action, because as discussed earlier, since we didn't define a mapDispatchToProps function, the connect function is going to inject a dispatch prop for us, this is a function that we will need to call to be able to fire an action that redux will handle, now we need to pass it an action like this:

    ```
    onClickSave() {
      this.props.dispatch(courseActions.createCourse());
    }
    ```    

    and createCourse is going to need a reference to some data, so we will pass it this.state.course like this:

    ```
    onClickSave() {
      this.props.dispatch(courseActions.createCourse(this.state.course));
    }
    ```    

    This looks ugly and there is a more elegent way to dispatch an action.

    So our file becomes:

    ```
    import React, {PropTypes} from 'react';
    import {connect} from 'react-redux';
    import * as courseActions from '../../actions/courseActions';

    class CoursesPage extends React.Component {
      constructor(props, context) {
        super(props, context);

        this.state = {
        //setting this to null will raise an error, make sure you use an initial value with an empty string ""
        course: { title: "" } 
        };

        this.onTitleChange = this.onTitleChange.bind(this);
        this.onClickSave = this.onClickSave.bind(this);
      }

      onTitleChange(event) {
      const course = this.state.course;
      course.title = event.target.value;
      this.setState({course: course});
      }

      onClickSave() {
        // alert(`Saving ${this.state.course.title}`);
        this.props.dispatch(courseActions.createCourse(this.state.course));
      }

      render() {
        return (
          <div>
            <h1>Courses</h1>
            <h2>Add Course</h2>
            <input
              type="text"
              onChange={this.onTitleChange}
              value={this.state.course.title} />

            <input
              type="submit"
              value="Save"
              onClick={this.onClickSave} />
          </div>
        );
      }
    }

    function mapStateToProps(state, ownProps) {
      return {
        courses: state.courses
      };
    }

    export default connect(mapStateToProps)(CoursesPage);
    ```

> **_//==============================================================\\_**
>
> **_Displaying the data in our component_**
>
> **_\\==============================================================//_**

Now we will update our CoursePage component's render function to display our data, and we will be able to step through the whole redux flow and see how it works.

Lets add this line to our render function in our component:

```
{this.props.courses.map(this.courseRow)}
```

So our render function becomes:

```
render() {
    return (
      <div>
        <h1>Courses</h1>
        {this.props.courses.map(this.courseRow)}
        <h2>Add Course</h2>
        <input
          type="text"
          onChange={this.onTitleChange}
          value={this.state.course.title} />

        <input
          type="submit"
          value="Save"
          onClick={this.onClickSave} />
      </div>
    );
}
```

now lets create the courseRow function:

```
courseRow(course, index) {
  return <div key={index}>{course.title}</div>
}
```

and our src/components/course/coursePage.js file becomes:

> Note: This is the first method of wiring up the call to dispatch.

```
import React, {PropTypes} from 'react';
import { connect } from 'react-redux';
import * as courseActions from '../../actions/courseActions';

class CoursesPage extends React.Component {
  constructor(props, context) {
    super(props, context);

    this.state = {
    course: { title: "" }
    };

    this.onTitleChange = this.onTitleChange.bind(this);
    this.onClickSave = this.onClickSave.bind(this);
  }

  onTitleChange(event) {
  const course = this.state.course;
  course.title = event.target.value;
  this.setState({course: course});
  }

  onClickSave() {
    this.props.dispatch(courseActions.createCourse(this.state.course));
  }

  courseRow(course, index) {
    return <div key={index}>{course.title}</div>;
  }

  render() {
    return (
      <div>
        <h1>Courses</h1>
        {this.props.courses.map(this.courseRow)}
        <h2>Add Course</h2>
        <input
          type="text"
          onChange={this.onTitleChange}
          value={this.state.course.title} />

        <input
          type="submit"
          value="Save"
          onClick={this.onClickSave} />
      </div>
    );
  }
}

CoursesPage.propTypes = {
  dispatch: PropTypes.func.isRequired,
  courses: PropTypes.array.isRequired
};

function mapStateToProps(state, ownProps) {
  return {
    courses: state.courses
  };
}

export default connect(mapStateToProps)(CoursesPage);
```

> **_//==============================================================\\_**
>
> **_STEPPING THROUGH REDUX FLOW_**
>
> **_\\==============================================================//_**

Here is the entire Redux flow:

01. ) We dispatched an action in the src/course/CoursePage.js file specifically at:

    ```
    onClickSave() {
      this.props.dispatch(courseActions.createCourse(this.state.course));
    }
    ```
01. ) Then that is landing at the src/actions/courseActions.js file in our "CREATE_COURSE" action creator.

    ```
    export function createCourse(course) {
      return {type: 'CREATE_COURSE', course};
    }
    ```

01. ) And that is handled in our src/reducers/courseReducer.js right here looking for the particular actionType:

    ```
    import objectAssign from 'object-assign';

    export default function courseReducer(state = [], action) {
      switch (action.type) {
        case 'CREATE_COURSE':
          return [...state,
            objectAssign({}, action.course)
          ];

        default:
          return state;
      }
    }
    ```

01. ) Then we land back in our mapStateToProps function in src/course/CoursePage.js where we pull the state and map it to our courses property:

    ```
    function mapStateToProps(state, ownProps) {
      return {
        courses: state.courses
      };
    }
    ```

01. ) Then finally the new render function is called here:

    ```
      render() {
        return (
          <div>
            <h1>Courses</h1>
            {this.props.courses.map(this.courseRow)}
            <h2>Add Course</h2>
            <input
              type="text"
              onChange={this.onTitleChange}
              value={this.state.course.title} />

            <input
              type="submit"
              value="Save"
              onClick={this.onClickSave} />
          </div>
        );
      }
    ```

    After our mapStateToProps function ends up injecting new data for our component.

> **_//==============================================================\\_**
>
> **_mapStateToProps manual mapping_**
>
> **_\\==============================================================//_**

When we first wired up the call to dispatch the createCourse action, we mentioned there was a cleaner way to get is done, that is accomplished with the second function we pass to the connect function, which is mapDispatchToProps.

The mapDispatchToProps function determines what actions are avaialble in the component, so lets add the reference here in the src/course/CoursePage.js and define it:

```
function mapDispatchToProps(dispatch) {
  return {
    createCourse: course => dispatch(courseActions.createCourse(course))
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(CoursesPage);
```

Then we can modify the onClickSave function as follows:

```
  onClickSave() {
    this.props.createCourse(this.state.course);
  }
```

What we did is wrapped the action creator in a call to dispatch like this: "dispatch(courseActions.createCourse(course))" this is how we mannually map actions to props.

Also note that if we didn't wrap the action creator "courseActions.createCourse(course)" in the call to dispatch: "dispatch(courseActions.createCourse(course))" the onClickSave function would do nothing but call the createCourse function in src/actions/createActions.js which just retruns an object, this object by its self does nothing, this will be like just referencing an object, but if we want to actually create a course we will have to call dispatch and that will trigger our flow through Redux.

Now that we have this mapping setup, that is the mapping of actions to props, we have declared that our component above will receive createCourse as a prop and will be wrapped in a call to dispatch.

> Note: Saying "The call to dispatch = "calling the dispatch function"

Finally we will have to update our props validation, by adding "createCourse" and remove "dispatch":

```
CoursesPage.propTypes = {
  courses: PropTypes.array.isRequired,
  createCourse: PropTypes.func.isRequired
};
```

We removed "dispatch" because it is no longer being injected as a property now that we have defined mapDispatchToProps function, once we started defining the mapDispatchToProps function, the function connect will no longer add a dispatch property on our component, remember we are passing "dispatch" in the mapDispatchToProps and is no longer injected in the component as before, and hence we can remove it from our prop validation.

so our src/course/CoursePage.js becomes:

> Note: This is the second method of wiring up the call to dispatch.

```
import React, {PropTypes} from 'react';
import { connect } from 'react-redux';
import * as courseActions from '../../actions/courseActions';

class CoursesPage extends React.Component {
  constructor(props, context) {
    super(props, context);

    this.state = {
    course: { title: "" }
    };

    this.onTitleChange = this.onTitleChange.bind(this);
    this.onClickSave = this.onClickSave.bind(this);
  }

  onTitleChange(event) {
  const course = this.state.course;
  course.title = event.target.value;
  this.setState({course: course});
  }

  onClickSave() {
    this.props.createCourse(this.state.course);
  }

  courseRow(course, index) {
    return <div key={index}>{course.title}</div>;
  }

  render() {
    return (
      <div>
        <h1>Courses</h1>
        {this.props.courses.map(this.courseRow)}
        <h2>Add Course</h2>
        <input
          type="text"
          onChange={this.onTitleChange}
          value={this.state.course.title} />

        <input
          type="submit"
          value="Save"
          onClick={this.onClickSave} />
      </div>
    );
  }
}

CoursesPage.propTypes = {
  courses: PropTypes.array.isRequired,
  createCourse: PropTypes.func.isRequired
};

function mapStateToProps(state, ownProps) {
  return {
    courses: state.courses
  };
}

function mapDispatchToProps(dispatch) {
  return {
    createCourse: course => dispatch(courseActions.createCourse(course))
  }
}

export default connect(mapStateToProps, mapDispatchToProps)(CoursesPage);
```

All we are doing is wrapping our action in call to dispatch so that it is easier to use above in our component.

> **_//==============================================================\\_**
>
> **_mapStateToProps mapping, the third way, using BindActionCreators_**
>
> **_\\==============================================================//_**

We just saw how mapDispatchToPorps simplified dispatching our action within our component, our call here in mapDispatchToPorps is still a bit verbose and can be more turse, Redux comes with a helper function that helps us avoid mannually wrapping our action creators in a dispatch call, the function is called bindActionCreators, so lets start using it.

01. ) Lets import it first:

    ```
    import {bindActionCreators} from 'redux';
    ```

01. ) Then we can using it in the mapDispatchToPorps function like this:

    ```
    function mapDispatchToProps(dispatch) {
      return {
        actions: bindActionCreators(courseActions, dispatch)
      };
    }
    ```

    The way this works is instead of doing this:
    
    ```
    function mapDispatchToProps(dispatch) {
      return {
        createCourse: course => dispatch(courseActions.createCourse(course))
      };
    }
    ```
    we call bindActionCreators like this:
    
    ```
    function mapDispatchToProps(dispatch) {
      return {
        createCourse: bindActionCreators(courseActions, dispatch)
      };
    }
    ```
    and it will do the work for us, we passed it the courseActions and our dispatch parameters, bindActionCreators will go through our courseActions and find all the actions in the file: src/actions/courseActions.js and wrap them in a call to dispatch, since it's going to be all those actions, we should change the parameter "createCourse" to "actions" like this:

    ```
    function mapDispatchToProps(dispatch) {
      return {
        actions: bindActionCreators(courseActions, dispatch)
      };
    }
    ```

    because now we will be mapping to all the actions in the file src/actions/courseActions.js and we can be expecting our actions to be placed in this.props.actions, it helps separate my actions from my courses, this also means we have to update our Proptypes validation by changing "courses" to actions:

    ```
    CoursesPage.propTypes = {
      courses: PropTypes.array.isRequired,
      actions: PropTypes.object.isRequired
    };
    ```

    also we have to change our onClickSave function to:

    ```
    onClickSave() {
      this.props.actions.createCourse(this.state.course);
    }
    ```

    To clarify, we didn't have to add action as an extra object here:

    ```
    function mapDispatchToProps(dispatch) {
      return {
        actions: bindActionCreators(courseActions, dispatch)
      };
    }
    ```

    we could have mapped a specific action here, we could have said courseActions.createCourse and then we could have left createCourse at the begining like this:

    ```
    function mapDispatchToProps(dispatch) {
      return {
        createCourse: bindActionCreators(courseActions.createCourse, dispatch)
      };
    }
    ```

    But is is better to keep the actions under actions like this:

    ```
    function mapDispatchToProps(dispatch) {
      return {
        actions: bindActionCreators(courseActions, dispatch)
      };
    }
    ```

    and map all of the course actions and wrap them in a dispatch, so the bindActionCreators is a handy way to reduce the amount of work in mapping my dispatch to props.
    
    so our src/course/CoursePage.js becomes:

  > Note: This is the third and prefered method of wiring up the call to dispatch.
    
    ```
    import React, {PropTypes} from 'react';
    import { connect } from 'react-redux';
    import * as courseActions from '../../actions/courseActions';
    import { bindActionCreators } from 'redux';

    class CoursesPage extends React.Component {
      constructor(props, context) {
        super(props, context);

        this.state = {
        course: { title: "" }
        };

        this.onTitleChange = this.onTitleChange.bind(this);
        this.onClickSave = this.onClickSave.bind(this);
      }

      onTitleChange(event) {
      const course = this.state.course;
      course.title = event.target.value;
      this.setState({course: course});
      }

      onClickSave() {
        this.props.actions.createCourse(this.state.course);
      }

      courseRow(course, index) {
        return <div key={index}>{course.title}</div>;
      }

      render() {
        return (
          <div>
            <h1>Courses</h1>
            {this.props.courses.map(this.courseRow)}
            <h2>Add Course</h2>
            <input
              type="text"
              onChange={this.onTitleChange}
              value={this.state.course.title} />

            <input
              type="submit"
              value="Save"
              onClick={this.onClickSave} />
          </div>
        );
      }
    }

    CoursesPage.propTypes = {
      courses: PropTypes.array.isRequired,
      actions: PropTypes.object.isRequired
    };

    function mapStateToProps(state, ownProps) {
      return {
        courses: state.courses
      };
    }

    function mapDispatchToProps(dispatch) {
      return {
        actions: bindActionCreators(courseActions, dispatch)
      };
    }

    export default connect(mapStateToProps, mapDispatchToProps)(CoursesPage);
    ```

    now lets make sure it works.

    run the app:

    ```
    npm start -s
    ```

    One last note is that you can call the functions: mapStateToProps and mapDispatchToProps anything you like.

> **_//==============================================================\\_**
>
> **_Review the structure of a container component_**
>
> **_\\==============================================================//_**


Our container component src/components/course/CoursePage.js has five main parts that utilizes all core pieces of Redux and React-Redux, And this is how it looks like:

```
import React, {PropTypes} from 'react';
import { connect } from 'react-redux';
import * as courseActions from '../../actions/courseActions';
import { bindActionCreators } from 'redux';

class CoursesPage extends React.Component {
  constructor(props, context) {
    super(props, context);

    this.state = {
    course: { title: "" }
    };

    this.onTitleChange = this.onTitleChange.bind(this);
    this.onClickSave = this.onClickSave.bind(this);
  }

  onTitleChange(event) {
  const course = this.state.course;
  course.title = event.target.value;
  this.setState({course: course});
  }

  onClickSave() {
    this.props.actions.createCourse(this.state.course);
  }

  courseRow(course, index) {
    return <div key={index}>{course.title}</div>;
  }

  render() {
    return (
      <div>
        <h1>Courses</h1>
        {this.props.courses.map(this.courseRow)}
        <h2>Add Course</h2>
        <input
          type="text"
          onChange={this.onTitleChange}
          value={this.state.course.title} />

        <input
          type="submit"
          value="Save"
          onClick={this.onClickSave} />
      </div>
    );
  }
}

CoursesPage.propTypes = {
  courses: PropTypes.array.isRequired,
  actions: PropTypes.object.isRequired
};

function mapStateToProps(state, ownProps) {
  return {
    courses: state.courses
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: bindActionCreators(courseActions, dispatch)
  };
}

export default connect(mapStateToProps, mapDispatchToProps)(CoursesPage);
```

These are the five main section of our container component:

01. ) The constructor:

    ```
    constructor(props, context) {
      super(props, context);

      this.state = {
      course: { title: "" }
      };

      this.onTitleChange = this.onTitleChange.bind(this);
      this.onClickSave = this.onClickSave.bind(this);
    }
    ```

    in the constructor we are going to initialize state:

    ```
    this.state = {
    course: { title: "" }
    };
    ```

    and we are going to call our bind functions:

    ```
    this.onTitleChange = this.onTitleChange.bind(this);
    this.onClickSave = this.onClickSave.bind(this);
    ```

01. ) Then we have our Child functions which are called by render:

    ```
    onTitleChange(event) {
    const course = this.state.course;
    course.title = event.target.value;
    this.setState({course: course});
    }

    onClickSave() {
      this.props.actions.createCourse(this.state.course);
    }

    courseRow(course, index) {
      return <div key={index}>{course.title}</div>;
    }
    ```

01. ) Then we have our render function where we would typically just call a child component:

    ```
    render() {
      return (
        <div>
          <h1>Courses</h1>
          {this.props.courses.map(this.courseRow)}
          <h2>Add Course</h2>
          <input
            type="text"
            onChange={this.onTitleChange}
            value={this.state.course.title} />

          <input
            type="submit"
            value="Save"
            onClick={this.onClickSave} />
        </div>
      );
    }
    ```

    we should typically keep the markup separate in a child component then we call that child component, but here for simplicity we kept the markup inline.

01. ) Then we have our proptypes that provide our prop types with validation:

    ```
    CoursesPage.propTypes = {
      courses: PropTypes.array.isRequired,
      actions: PropTypes.object.isRequired
    };
    ```

01. ) Finally we have our redux connect and related functions

    ```
    function mapStateToProps(state, ownProps) {
      return {
        courses: state.courses
      };
    }

    function mapDispatchToProps(dispatch) {
      return {
        actions: bindActionCreators(courseActions, dispatch)
      };
    }

    export default connect(mapStateToProps, mapDispatchToProps)(CoursesPage);
    ```

> **_//==============================================================\\_**
>
> **_Using Action Type Constants_**
>
> **_\\==============================================================//_**

We are going to create a file called actionTypes.js and in it we will put all our action constants, under the src/actions folder create a file called: src/actions/actionTypes.js, in the file put the constat CREATE_COURSE:

```
export const CREATE_COURSE = 'CREATE_COURSE';
```

Then in the src/actions/courseActions.js file import the constant by typing on the top line:

```
import * as types from './actionTypes'; 
```

So our src/actions/courseActions.js file becomes:

```
import * as types from './actionTypes';

export function createCourse(course) {
  return {type: types.CREATE_COURSE, course};
}
```

We also have to use it in our src/reducers/courseReducer.js like this:

```
import objectAssign from 'object-assign';
import * as types from '../actions/actionTypes';

export default function courseReducer(state = [], action) {
  switch (action.type) {
    case types.CREATE_COURSE:
      return [...state,
        objectAssign({}, action.course)
      ];

    default:
      return state;
  }
}
```

Now run the app and make sure it is running as expected.

> **_//==============================================================\\_**
>
> **_Using a Mock API_**
>
> **_\\==============================================================//_**

We will be using a mock api instead of a real one for the sake of development.

Create the folder src/api, then in it create the following three files:

delay.js with the following code:

```
export default 1000;
```

mockAuthorApi.js with the following code:

```
import delay from './delay';

// This file mocks a web API by working with the hard-coded data below.
// It uses setTimeout to simulate the delay of an AJAX call.
// All calls return promises.
const authors = [
  {
    id: 'cory-house',
    firstName: 'Cory',
    lastName: 'House'
  },
  {
    id: 'scott-allen',
    firstName: 'Scott',
    lastName: 'Allen'
  },
  {
    id: 'dan-wahlin',
    firstName: 'Dan',
    lastName: 'Wahlin'
  }
];

//This would be performed on the server in a real app. Just stubbing in.
const generateId = (author) => {
  return author.firstName.toLowerCase() + '-' + author.lastName.toLowerCase();
};

class AuthorApi {
  static getAllAuthors() {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve(Object.assign([], authors));
      }, delay);
    });
  }

  static saveAuthor(author) {
	author = Object.assign({}, author); // to avoid manipulating object passed in.
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        // Simulate server-side validation
        const minAuthorNameLength = 3;
        if (author.firstName.length < minAuthorNameLength) {
          reject(`First Name must be at least ${minAuthorNameLength} characters.`);
        }

        if (author.lastName.length < minAuthorNameLength) {
          reject(`Last Name must be at least ${minAuthorNameLength} characters.`);
        }

        if (author.id) {
          const existingAuthorIndex = authors.findIndex(a => a.id == author.id);
          authors.splice(existingAuthorIndex, 1, author);
        } else {
          //Just simulating creation here.
          //The server would generate ids for new authors in a real app.
          //Cloning so copy returned is passed by value rather than by reference.
          author.id = generateId(author);
          authors.push(author);
        }

        resolve(author);
      }, delay);
    });
  }

  static deleteAuthor(authorId) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        const indexOfAuthorToDelete = authors.findIndex(author => {
          author.id == authorId;
        });
        authors.splice(indexOfAuthorToDelete, 1);
        resolve();
      }, delay);
    });
  }
}

export default AuthorApi;
```

mockAuthorApi.js with the following code:

```
import delay from './delay';

// This file mocks a web API by working with the hard-coded data below.
// It uses setTimeout to simulate the delay of an AJAX call.
// All calls return promises.
const courses = [
  {
    id: "react-flux-building-applications",
    title: "Building Applications in React and Flux",
    watchHref: "http://www.pluralsight.com/courses/react-flux-building-applications",
    authorId: "cory-house",
    length: "5:08",
    category: "JavaScript"
  },
  {
    id: "clean-code",
    title: "Clean Code: Writing Code for Humans",
    watchHref: "http://www.pluralsight.com/courses/writing-clean-code-humans",
    authorId: "cory-house",
    length: "3:10",
    category: "Software Practices"
  },
  {
    id: "architecture",
    title: "Architecting Applications for the Real World",
    watchHref: "http://www.pluralsight.com/courses/architecting-applications-dotnet",
    authorId: "cory-house",
    length: "2:52",
    category: "Software Architecture"
  },
  {
    id: "career-reboot-for-developer-mind",
    title: "Becoming an Outlier: Reprogramming the Developer Mind",
    watchHref: "http://www.pluralsight.com/courses/career-reboot-for-developer-mind",
    authorId: "cory-house",
    length: "2:30",
    category: "Career"
  },
  {
    id: "web-components-shadow-dom",
    title: "Web Component Fundamentals",
    watchHref: "http://www.pluralsight.com/courses/web-components-shadow-dom",
    authorId: "cory-house",
    length: "5:10",
    category: "HTML5"
  }
];

function replaceAll(str, find, replace) {
  return str.replace(new RegExp(find, 'g'), replace);
}

//This would be performed on the server in a real app. Just stubbing in.
const generateId = (course) => {
  return replaceAll(course.title, ' ', '-');
};

class CourseApi {
  static getAllCourses() {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve(Object.assign([], courses));
      }, delay);
    });
  }

  static saveCourse(course) {
    course = Object.assign({}, course); // to avoid manipulating object passed in.
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        // Simulate server-side validation
        const minCourseTitleLength = 1;
        if (course.title.length < minCourseTitleLength) {
          reject(`Title must be at least ${minCourseTitleLength} characters.`);
        }

        if (course.id) {
          const existingCourseIndex = courses.findIndex(a => a.id == course.id);
          courses.splice(existingCourseIndex, 1, course);
        } else {
          //Just simulating creation here.
          //The server would generate ids and watchHref's for new courses in a real app.
          //Cloning so copy returned is passed by value rather than by reference.
          course.id = generateId(course);
          course.watchHref = `http://www.pluralsight.com/courses/${course.id}`;
          courses.push(course);
        }

        resolve(course);
      }, delay);
    });
  }

  static deleteCourse(courseId) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        const indexOfCourseToDelete = courses.findIndex(course => {
          course.id == courseId;
        });
        courses.splice(indexOfCourseToDelete, 1);
        resolve();
      }, delay);
    });
  }
}

export default CourseApi;
```
